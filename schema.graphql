schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

type Company {
  email: String
  id: uuid
  name: String
}

input EmployerProfileInput {
  email: String
  employer_id: uuid!
  name: String
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

type Job {
  company: Company
  company_id: uuid
  created_at: String
  description: String
  id: uuid
  location: String
  title: String
  type: String
}

input JobInput {
  company_id: uuid!
  description: String
  is_active: Boolean
  location: String
  title: String!
  type: String
}

input JobUserInput {
  job_id: uuid!
  user_id: uuid!
}

input JobsQueryInput {
  is_active: Boolean
  title: String
}

input MyJobsQueryInput {
  user_id: uuid!
}

input PostJobInput {
  job: JobInput!
  user_id: uuid!
}

type Profile {
  address: String
  email: String!
  name: String!
  user: User
}

input SeekerProfileInput {
  email: String
  name: String
  user_id: uuid!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type User {
  avatar_url: String
  default_role: String
  display_name: String!
  email: String
  email_verified: Boolean
}

"""
columns and relationships of "application_status"
"""
type application_status {
  status: String!
}

"""
aggregated selection of "application_status"
"""
type application_status_aggregate {
  aggregate: application_status_aggregate_fields
  nodes: [application_status!]!
}

"""
aggregate fields of "application_status"
"""
type application_status_aggregate_fields {
  count(columns: [application_status_select_column!], distinct: Boolean): Int!
  max: application_status_max_fields
  min: application_status_min_fields
}

"""
Boolean expression to filter rows from the table "application_status". All fields are combined with a logical 'AND'.
"""
input application_status_bool_exp {
  _and: [application_status_bool_exp!]
  _not: application_status_bool_exp
  _or: [application_status_bool_exp!]
  status: String_comparison_exp
}

"""
unique or primary key constraints on table "application_status"
"""
enum application_status_constraint {
  """
  unique or primary key constraint on columns "status"
  """
  application_status_pkey
}

"""
input type for inserting data into table "application_status"
"""
input application_status_insert_input {
  status: String
}

"""aggregate max on columns"""
type application_status_max_fields {
  status: String
}

"""aggregate min on columns"""
type application_status_min_fields {
  status: String
}

"""
response of any mutation on the table "application_status"
"""
type application_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [application_status!]!
}

"""
input type for inserting object relation for remote table "application_status"
"""
input application_status_obj_rel_insert_input {
  data: application_status_insert_input!

  """upsert condition"""
  on_conflict: application_status_on_conflict
}

"""
on_conflict condition type for table "application_status"
"""
input application_status_on_conflict {
  constraint: application_status_constraint!
  update_columns: [application_status_update_column!]! = []
  where: application_status_bool_exp
}

"""Ordering options when selecting data from "application_status"."""
input application_status_order_by {
  status: order_by
}

"""primary key columns input for table: application_status"""
input application_status_pk_columns_input {
  status: String!
}

"""
select columns of table "application_status"
"""
enum application_status_select_column {
  """column name"""
  status
}

"""
input type for updating data in table "application_status"
"""
input application_status_set_input {
  status: String
}

"""
Streaming cursor of the table "application_status"
"""
input application_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: application_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input application_status_stream_cursor_value_input {
  status: String
}

"""
update columns of table "application_status"
"""
enum application_status_update_column {
  """column name"""
  status
}

input application_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: application_status_set_input
  where: application_status_bool_exp!
}

"""
columns and relationships of "applications"
"""
type applications {
  """An array relationship"""
  applicants(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  applicants_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """An object relationship"""
  applicationStatus: application_status
  created_at: timestamptz
  deleted_at: timestamptz
  is_active: Boolean

  """An object relationship"""
  job: jobs!
  job_id: uuid!
  status: String!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "applications"
"""
type applications_aggregate {
  aggregate: applications_aggregate_fields
  nodes: [applications!]!
}

input applications_aggregate_bool_exp {
  bool_and: applications_aggregate_bool_exp_bool_and
  bool_or: applications_aggregate_bool_exp_bool_or
  count: applications_aggregate_bool_exp_count
}

input applications_aggregate_bool_exp_bool_and {
  arguments: applications_select_column_applications_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: applications_bool_exp
  predicate: Boolean_comparison_exp!
}

input applications_aggregate_bool_exp_bool_or {
  arguments: applications_select_column_applications_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: applications_bool_exp
  predicate: Boolean_comparison_exp!
}

input applications_aggregate_bool_exp_count {
  arguments: [applications_select_column!]
  distinct: Boolean
  filter: applications_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "applications"
"""
type applications_aggregate_fields {
  count(columns: [applications_select_column!], distinct: Boolean): Int!
  max: applications_max_fields
  min: applications_min_fields
}

"""
order by aggregate values of table "applications"
"""
input applications_aggregate_order_by {
  count: order_by
  max: applications_max_order_by
  min: applications_min_order_by
}

"""
input type for inserting array relation for remote table "applications"
"""
input applications_arr_rel_insert_input {
  data: [applications_insert_input!]!

  """upsert condition"""
  on_conflict: applications_on_conflict
}

"""
Boolean expression to filter rows from the table "applications". All fields are combined with a logical 'AND'.
"""
input applications_bool_exp {
  _and: [applications_bool_exp!]
  _not: applications_bool_exp
  _or: [applications_bool_exp!]
  applicants: users_bool_exp
  applicants_aggregate: users_aggregate_bool_exp
  applicationStatus: application_status_bool_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  is_active: Boolean_comparison_exp
  job: jobs_bool_exp
  job_id: uuid_comparison_exp
  status: String_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "applications"
"""
enum applications_constraint {
  """
  unique or primary key constraint on columns "job_id", "user_id"
  """
  applications_pkey

  """
  unique or primary key constraint on columns "job_id", "user_id"
  """
  profile_job
}

"""
input type for inserting data into table "applications"
"""
input applications_insert_input {
  applicants: users_arr_rel_insert_input
  applicationStatus: application_status_obj_rel_insert_input
  created_at: timestamptz
  deleted_at: timestamptz
  is_active: Boolean
  job: jobs_obj_rel_insert_input
  job_id: uuid
  status: String
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type applications_max_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  job_id: uuid
  status: String
  user_id: uuid
}

"""
order by max() on columns of table "applications"
"""
input applications_max_order_by {
  created_at: order_by
  deleted_at: order_by
  job_id: order_by
  status: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type applications_min_fields {
  created_at: timestamptz
  deleted_at: timestamptz
  job_id: uuid
  status: String
  user_id: uuid
}

"""
order by min() on columns of table "applications"
"""
input applications_min_order_by {
  created_at: order_by
  deleted_at: order_by
  job_id: order_by
  status: order_by
  user_id: order_by
}

"""
response of any mutation on the table "applications"
"""
type applications_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [applications!]!
}

"""
on_conflict condition type for table "applications"
"""
input applications_on_conflict {
  constraint: applications_constraint!
  update_columns: [applications_update_column!]! = []
  where: applications_bool_exp
}

"""Ordering options when selecting data from "applications"."""
input applications_order_by {
  applicants_aggregate: users_aggregate_order_by
  applicationStatus: application_status_order_by
  created_at: order_by
  deleted_at: order_by
  is_active: order_by
  job: jobs_order_by
  job_id: order_by
  status: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: applications"""
input applications_pk_columns_input {
  job_id: uuid!
  user_id: uuid!
}

"""
select columns of table "applications"
"""
enum applications_select_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  is_active

  """column name"""
  job_id

  """column name"""
  status

  """column name"""
  user_id
}

"""
select "applications_aggregate_bool_exp_bool_and_arguments_columns" columns of table "applications"
"""
enum applications_select_column_applications_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active
}

"""
select "applications_aggregate_bool_exp_bool_or_arguments_columns" columns of table "applications"
"""
enum applications_select_column_applications_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active
}

"""
input type for updating data in table "applications"
"""
input applications_set_input {
  created_at: timestamptz
  deleted_at: timestamptz
  is_active: Boolean
  job_id: uuid
  status: String
  user_id: uuid
}

"""
Streaming cursor of the table "applications"
"""
input applications_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: applications_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input applications_stream_cursor_value_input {
  created_at: timestamptz
  deleted_at: timestamptz
  is_active: Boolean
  job_id: uuid
  status: String
  user_id: uuid
}

"""
update columns of table "applications"
"""
enum applications_update_column {
  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  is_active

  """column name"""
  job_id

  """column name"""
  status

  """column name"""
  user_id
}

input applications_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: applications_set_input
  where: applications_bool_exp!
}

"""
fields of action: "applyJob"
"""
type applyJob {
  """the time at which this action was created"""
  created_at: timestamptz!

  """errors related to the invocation"""
  errors: json

  """the unique id of an action"""
  id: uuid!

  """the output fields of this action"""
  output: Job
}

"""
Oauth requests, inserted before redirecting to the provider's site. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviderRequests {
  id: uuid!
  options(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "auth.provider_requests"
"""
type authProviderRequests_aggregate {
  aggregate: authProviderRequests_aggregate_fields
  nodes: [authProviderRequests!]!
}

"""
aggregate fields of "auth.provider_requests"
"""
type authProviderRequests_aggregate_fields {
  count(columns: [authProviderRequests_select_column!], distinct: Boolean): Int!
  max: authProviderRequests_max_fields
  min: authProviderRequests_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_append_input {
  options: jsonb
}

"""
Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'.
"""
input authProviderRequests_bool_exp {
  _and: [authProviderRequests_bool_exp!]
  _not: authProviderRequests_bool_exp
  _or: [authProviderRequests_bool_exp!]
  id: uuid_comparison_exp
  options: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auth.provider_requests"
"""
enum authProviderRequests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  provider_requests_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authProviderRequests_delete_at_path_input {
  options: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input authProviderRequests_delete_elem_input {
  options: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authProviderRequests_delete_key_input {
  options: String
}

"""
input type for inserting data into table "auth.provider_requests"
"""
input authProviderRequests_insert_input {
  id: uuid
  options: jsonb
}

"""aggregate max on columns"""
type authProviderRequests_max_fields {
  id: uuid
}

"""aggregate min on columns"""
type authProviderRequests_min_fields {
  id: uuid
}

"""
response of any mutation on the table "auth.provider_requests"
"""
type authProviderRequests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviderRequests!]!
}

"""
on_conflict condition type for table "auth.provider_requests"
"""
input authProviderRequests_on_conflict {
  constraint: authProviderRequests_constraint!
  update_columns: [authProviderRequests_update_column!]! = []
  where: authProviderRequests_bool_exp
}

"""Ordering options when selecting data from "auth.provider_requests"."""
input authProviderRequests_order_by {
  id: order_by
  options: order_by
}

"""primary key columns input for table: auth.provider_requests"""
input authProviderRequests_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_prepend_input {
  options: jsonb
}

"""
select columns of table "auth.provider_requests"
"""
enum authProviderRequests_select_column {
  """column name"""
  id

  """column name"""
  options
}

"""
input type for updating data in table "auth.provider_requests"
"""
input authProviderRequests_set_input {
  id: uuid
  options: jsonb
}

"""
Streaming cursor of the table "authProviderRequests"
"""
input authProviderRequests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviderRequests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviderRequests_stream_cursor_value_input {
  id: uuid
  options: jsonb
}

"""
update columns of table "auth.provider_requests"
"""
enum authProviderRequests_update_column {
  """column name"""
  id

  """column name"""
  options
}

input authProviderRequests_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authProviderRequests_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authProviderRequests_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: authProviderRequests_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authProviderRequests_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authProviderRequests_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authProviderRequests_set_input
  where: authProviderRequests_bool_exp!
}

"""
List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviders {
  id: String!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.providers"
"""
type authProviders_aggregate {
  aggregate: authProviders_aggregate_fields
  nodes: [authProviders!]!
}

"""
aggregate fields of "auth.providers"
"""
type authProviders_aggregate_fields {
  count(columns: [authProviders_select_column!], distinct: Boolean): Int!
  max: authProviders_max_fields
  min: authProviders_min_fields
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input authProviders_bool_exp {
  _and: [authProviders_bool_exp!]
  _not: authProviders_bool_exp
  _or: [authProviders_bool_exp!]
  id: String_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum authProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input authProviders_insert_input {
  id: String
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type authProviders_max_fields {
  id: String
}

"""aggregate min on columns"""
type authProviders_min_fields {
  id: String
}

"""
response of any mutation on the table "auth.providers"
"""
type authProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviders!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input authProviders_obj_rel_insert_input {
  data: authProviders_insert_input!

  """upsert condition"""
  on_conflict: authProviders_on_conflict
}

"""
on_conflict condition type for table "auth.providers"
"""
input authProviders_on_conflict {
  constraint: authProviders_constraint!
  update_columns: [authProviders_update_column!]! = []
  where: authProviders_bool_exp
}

"""Ordering options when selecting data from "auth.providers"."""
input authProviders_order_by {
  id: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.providers"""
input authProviders_pk_columns_input {
  id: String!
}

"""
select columns of table "auth.providers"
"""
enum authProviders_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "auth.providers"
"""
input authProviders_set_input {
  id: String
}

"""
Streaming cursor of the table "authProviders"
"""
input authProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviders_stream_cursor_value_input {
  id: String
}

"""
update columns of table "auth.providers"
"""
enum authProviders_update_column {
  """column name"""
  id
}

input authProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authProviders_set_input
  where: authProviders_bool_exp!
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long as the refresh token is not expired. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRefreshTokens {
  createdAt: timestamptz!
  expiresAt: timestamptz!
  refreshToken: uuid!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate {
  aggregate: authRefreshTokens_aggregate_fields
  nodes: [authRefreshTokens!]!
}

input authRefreshTokens_aggregate_bool_exp {
  count: authRefreshTokens_aggregate_bool_exp_count
}

input authRefreshTokens_aggregate_bool_exp_count {
  arguments: [authRefreshTokens_select_column!]
  distinct: Boolean
  filter: authRefreshTokens_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate_fields {
  count(columns: [authRefreshTokens_select_column!], distinct: Boolean): Int!
  max: authRefreshTokens_max_fields
  min: authRefreshTokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
  count: order_by
  max: authRefreshTokens_max_order_by
  min: authRefreshTokens_min_order_by
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input authRefreshTokens_arr_rel_insert_input {
  data: [authRefreshTokens_insert_input!]!

  """upsert condition"""
  on_conflict: authRefreshTokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
  _and: [authRefreshTokens_bool_exp!]
  _not: authRefreshTokens_bool_exp
  _or: [authRefreshTokens_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  refreshToken: uuid_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum authRefreshTokens_constraint {
  """
  unique or primary key constraint on columns "refresh_token"
  """
  refresh_tokens_pkey
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input authRefreshTokens_insert_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authRefreshTokens_max_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authRefreshTokens_min_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokens!]!
}

"""
on_conflict condition type for table "auth.refresh_tokens"
"""
input authRefreshTokens_on_conflict {
  constraint: authRefreshTokens_constraint!
  update_columns: [authRefreshTokens_update_column!]! = []
  where: authRefreshTokens_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input authRefreshTokens_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.refresh_tokens"""
input authRefreshTokens_pk_columns_input {
  refreshToken: uuid!
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  refreshToken

  """column name"""
  userId
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input authRefreshTokens_set_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
Streaming cursor of the table "authRefreshTokens"
"""
input authRefreshTokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokens_stream_cursor_value_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  refreshToken

  """column name"""
  userId
}

input authRefreshTokens_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokens_set_input
  where: authRefreshTokens_bool_exp!
}

"""
Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRoles {
  role: String!

  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  userRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  usersByDefaultRole(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersByDefaultRole_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "auth.roles"
"""
type authRoles_aggregate {
  aggregate: authRoles_aggregate_fields
  nodes: [authRoles!]!
}

"""
aggregate fields of "auth.roles"
"""
type authRoles_aggregate_fields {
  count(columns: [authRoles_select_column!], distinct: Boolean): Int!
  max: authRoles_max_fields
  min: authRoles_min_fields
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input authRoles_bool_exp {
  _and: [authRoles_bool_exp!]
  _not: authRoles_bool_exp
  _or: [authRoles_bool_exp!]
  role: String_comparison_exp
  userRoles: authUserRoles_bool_exp
  userRoles_aggregate: authUserRoles_aggregate_bool_exp
  usersByDefaultRole: users_bool_exp
  usersByDefaultRole_aggregate: users_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum authRoles_constraint {
  """
  unique or primary key constraint on columns "role"
  """
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input authRoles_insert_input {
  role: String
  userRoles: authUserRoles_arr_rel_insert_input
  usersByDefaultRole: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type authRoles_max_fields {
  role: String
}

"""aggregate min on columns"""
type authRoles_min_fields {
  role: String
}

"""
response of any mutation on the table "auth.roles"
"""
type authRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRoles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input authRoles_obj_rel_insert_input {
  data: authRoles_insert_input!

  """upsert condition"""
  on_conflict: authRoles_on_conflict
}

"""
on_conflict condition type for table "auth.roles"
"""
input authRoles_on_conflict {
  constraint: authRoles_constraint!
  update_columns: [authRoles_update_column!]! = []
  where: authRoles_bool_exp
}

"""Ordering options when selecting data from "auth.roles"."""
input authRoles_order_by {
  role: order_by
  userRoles_aggregate: authUserRoles_aggregate_order_by
  usersByDefaultRole_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: auth.roles"""
input authRoles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum authRoles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input authRoles_set_input {
  role: String
}

"""
Streaming cursor of the table "authRoles"
"""
input authRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRoles_stream_cursor_value_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum authRoles_update_column {
  """column name"""
  role
}

input authRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRoles_set_input
  where: authRoles_bool_exp!
}

"""
Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserProviders {
  accessToken: String!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: authProviders!
  providerId: String!
  providerUserId: String!
  refreshToken: String
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_providers"
"""
type authUserProviders_aggregate {
  aggregate: authUserProviders_aggregate_fields
  nodes: [authUserProviders!]!
}

input authUserProviders_aggregate_bool_exp {
  count: authUserProviders_aggregate_bool_exp_count
}

input authUserProviders_aggregate_bool_exp_count {
  arguments: [authUserProviders_select_column!]
  distinct: Boolean
  filter: authUserProviders_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_providers"
"""
type authUserProviders_aggregate_fields {
  count(columns: [authUserProviders_select_column!], distinct: Boolean): Int!
  max: authUserProviders_max_fields
  min: authUserProviders_min_fields
}

"""
order by aggregate values of table "auth.user_providers"
"""
input authUserProviders_aggregate_order_by {
  count: order_by
  max: authUserProviders_max_order_by
  min: authUserProviders_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_providers"
"""
input authUserProviders_arr_rel_insert_input {
  data: [authUserProviders_insert_input!]!

  """upsert condition"""
  on_conflict: authUserProviders_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
"""
input authUserProviders_bool_exp {
  _and: [authUserProviders_bool_exp!]
  _not: authUserProviders_bool_exp
  _or: [authUserProviders_bool_exp!]
  accessToken: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: authProviders_bool_exp
  providerId: String_comparison_exp
  providerUserId: String_comparison_exp
  refreshToken: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_providers"
"""
enum authUserProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_providers_pkey

  """
  unique or primary key constraint on columns "provider_id", "provider_user_id"
  """
  user_providers_provider_id_provider_user_id_key

  """
  unique or primary key constraint on columns "provider_id", "user_id"
  """
  user_providers_user_id_provider_id_key
}

"""
input type for inserting data into table "auth.user_providers"
"""
input authUserProviders_insert_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  provider: authProviders_obj_rel_insert_input
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserProviders_max_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "auth.user_providers"
"""
input authUserProviders_max_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserProviders_min_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "auth.user_providers"
"""
input authUserProviders_min_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_providers"
"""
type authUserProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserProviders!]!
}

"""
on_conflict condition type for table "auth.user_providers"
"""
input authUserProviders_on_conflict {
  constraint: authUserProviders_constraint!
  update_columns: [authUserProviders_update_column!]! = []
  where: authUserProviders_bool_exp
}

"""Ordering options when selecting data from "auth.user_providers"."""
input authUserProviders_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  provider: authProviders_order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_providers"""
input authUserProviders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_providers"
"""
enum authUserProviders_select_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_providers"
"""
input authUserProviders_set_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "authUserProviders"
"""
input authUserProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserProviders_stream_cursor_value_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "auth.user_providers"
"""
enum authUserProviders_update_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

input authUserProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserProviders_set_input
  where: authUserProviders_bool_exp!
}

"""
Roles of users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserRoles {
  createdAt: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: authRoles!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_roles"
"""
type authUserRoles_aggregate {
  aggregate: authUserRoles_aggregate_fields
  nodes: [authUserRoles!]!
}

input authUserRoles_aggregate_bool_exp {
  count: authUserRoles_aggregate_bool_exp_count
}

input authUserRoles_aggregate_bool_exp_count {
  arguments: [authUserRoles_select_column!]
  distinct: Boolean
  filter: authUserRoles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_roles"
"""
type authUserRoles_aggregate_fields {
  count(columns: [authUserRoles_select_column!], distinct: Boolean): Int!
  max: authUserRoles_max_fields
  min: authUserRoles_min_fields
}

"""
order by aggregate values of table "auth.user_roles"
"""
input authUserRoles_aggregate_order_by {
  count: order_by
  max: authUserRoles_max_order_by
  min: authUserRoles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_roles"
"""
input authUserRoles_arr_rel_insert_input {
  data: [authUserRoles_insert_input!]!

  """upsert condition"""
  on_conflict: authUserRoles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'.
"""
input authUserRoles_bool_exp {
  _and: [authUserRoles_bool_exp!]
  _not: authUserRoles_bool_exp
  _or: [authUserRoles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: authRoles_bool_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_roles"
"""
enum authUserRoles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "role"
  """
  user_roles_user_id_role_key
}

"""
input type for inserting data into table "auth.user_roles"
"""
input authUserRoles_insert_input {
  createdAt: timestamptz
  id: uuid
  role: String
  roleByRole: authRoles_obj_rel_insert_input
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserRoles_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_roles"
"""
input authUserRoles_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserRoles_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_roles"
"""
input authUserRoles_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_roles"
"""
type authUserRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserRoles!]!
}

"""
on_conflict condition type for table "auth.user_roles"
"""
input authUserRoles_on_conflict {
  constraint: authUserRoles_constraint!
  update_columns: [authUserRoles_update_column!]! = []
  where: authUserRoles_bool_exp
}

"""Ordering options when selecting data from "auth.user_roles"."""
input authUserRoles_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  roleByRole: authRoles_order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_roles"""
input authUserRoles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_roles"
"""
enum authUserRoles_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_roles"
"""
input authUserRoles_set_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
Streaming cursor of the table "authUserRoles"
"""
input authUserRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserRoles_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
update columns of table "auth.user_roles"
"""
enum authUserRoles_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

input authUserRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserRoles_set_input
  where: authUserRoles_bool_exp!
}

"""
User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserSecurityKeys {
  counter: bigint!
  credentialId: String!
  credentialPublicKey: bytea
  id: uuid!
  nickname: String
  transports: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate {
  aggregate: authUserSecurityKeys_aggregate_fields
  nodes: [authUserSecurityKeys!]!
}

input authUserSecurityKeys_aggregate_bool_exp {
  count: authUserSecurityKeys_aggregate_bool_exp_count
}

input authUserSecurityKeys_aggregate_bool_exp_count {
  arguments: [authUserSecurityKeys_select_column!]
  distinct: Boolean
  filter: authUserSecurityKeys_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate_fields {
  avg: authUserSecurityKeys_avg_fields
  count(columns: [authUserSecurityKeys_select_column!], distinct: Boolean): Int!
  max: authUserSecurityKeys_max_fields
  min: authUserSecurityKeys_min_fields
  stddev: authUserSecurityKeys_stddev_fields
  stddev_pop: authUserSecurityKeys_stddev_pop_fields
  stddev_samp: authUserSecurityKeys_stddev_samp_fields
  sum: authUserSecurityKeys_sum_fields
  var_pop: authUserSecurityKeys_var_pop_fields
  var_samp: authUserSecurityKeys_var_samp_fields
  variance: authUserSecurityKeys_variance_fields
}

"""
order by aggregate values of table "auth.user_security_keys"
"""
input authUserSecurityKeys_aggregate_order_by {
  avg: authUserSecurityKeys_avg_order_by
  count: order_by
  max: authUserSecurityKeys_max_order_by
  min: authUserSecurityKeys_min_order_by
  stddev: authUserSecurityKeys_stddev_order_by
  stddev_pop: authUserSecurityKeys_stddev_pop_order_by
  stddev_samp: authUserSecurityKeys_stddev_samp_order_by
  sum: authUserSecurityKeys_sum_order_by
  var_pop: authUserSecurityKeys_var_pop_order_by
  var_samp: authUserSecurityKeys_var_samp_order_by
  variance: authUserSecurityKeys_variance_order_by
}

"""
input type for inserting array relation for remote table "auth.user_security_keys"
"""
input authUserSecurityKeys_arr_rel_insert_input {
  data: [authUserSecurityKeys_insert_input!]!

  """upsert condition"""
  on_conflict: authUserSecurityKeys_on_conflict
}

"""aggregate avg on columns"""
type authUserSecurityKeys_avg_fields {
  counter: Float
}

"""
order by avg() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_avg_order_by {
  counter: order_by
}

"""
Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
"""
input authUserSecurityKeys_bool_exp {
  _and: [authUserSecurityKeys_bool_exp!]
  _not: authUserSecurityKeys_bool_exp
  _or: [authUserSecurityKeys_bool_exp!]
  counter: bigint_comparison_exp
  credentialId: String_comparison_exp
  credentialPublicKey: bytea_comparison_exp
  id: uuid_comparison_exp
  nickname: String_comparison_exp
  transports: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_security_keys"
"""
enum authUserSecurityKeys_constraint {
  """
  unique or primary key constraint on columns "credential_id"
  """
  user_security_key_credential_id_key

  """
  unique or primary key constraint on columns "id"
  """
  user_security_keys_pkey
}

"""
input type for incrementing numeric columns in table "auth.user_security_keys"
"""
input authUserSecurityKeys_inc_input {
  counter: bigint
}

"""
input type for inserting data into table "auth.user_security_keys"
"""
input authUserSecurityKeys_insert_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserSecurityKeys_max_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_max_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserSecurityKeys_min_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_min_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_security_keys"
"""
type authUserSecurityKeys_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserSecurityKeys!]!
}

"""
on_conflict condition type for table "auth.user_security_keys"
"""
input authUserSecurityKeys_on_conflict {
  constraint: authUserSecurityKeys_constraint!
  update_columns: [authUserSecurityKeys_update_column!]! = []
  where: authUserSecurityKeys_bool_exp
}

"""Ordering options when selecting data from "auth.user_security_keys"."""
input authUserSecurityKeys_order_by {
  counter: order_by
  credentialId: order_by
  credentialPublicKey: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_security_keys"""
input authUserSecurityKeys_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_select_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_security_keys"
"""
input authUserSecurityKeys_set_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate stddev on columns"""
type authUserSecurityKeys_stddev_fields {
  counter: Float
}

"""
order by stddev() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_order_by {
  counter: order_by
}

"""aggregate stddev_pop on columns"""
type authUserSecurityKeys_stddev_pop_fields {
  counter: Float
}

"""
order by stddev_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_pop_order_by {
  counter: order_by
}

"""aggregate stddev_samp on columns"""
type authUserSecurityKeys_stddev_samp_fields {
  counter: Float
}

"""
order by stddev_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_samp_order_by {
  counter: order_by
}

"""
Streaming cursor of the table "authUserSecurityKeys"
"""
input authUserSecurityKeys_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserSecurityKeys_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserSecurityKeys_stream_cursor_value_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate sum on columns"""
type authUserSecurityKeys_sum_fields {
  counter: bigint
}

"""
order by sum() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_sum_order_by {
  counter: order_by
}

"""
update columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_update_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

input authUserSecurityKeys_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: authUserSecurityKeys_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: authUserSecurityKeys_set_input
  where: authUserSecurityKeys_bool_exp!
}

"""aggregate var_pop on columns"""
type authUserSecurityKeys_var_pop_fields {
  counter: Float
}

"""
order by var_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_pop_order_by {
  counter: order_by
}

"""aggregate var_samp on columns"""
type authUserSecurityKeys_var_samp_fields {
  counter: Float
}

"""
order by var_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_samp_order_by {
  counter: order_by
}

"""aggregate variance on columns"""
type authUserSecurityKeys_variance_fields {
  counter: Float
}

"""
order by variance() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_variance_order_by {
  counter: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
columns and relationships of "storage.buckets"
"""
type buckets {
  cacheControl: String
  createdAt: timestamptz!
  downloadExpiration: Int!

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  id: String!
  maxUploadFileSize: Int!
  minUploadFileSize: Int!
  presignedUrlsEnabled: Boolean!
  updatedAt: timestamptz!
}

"""
aggregated selection of "storage.buckets"
"""
type buckets_aggregate {
  aggregate: buckets_aggregate_fields
  nodes: [buckets!]!
}

"""
aggregate fields of "storage.buckets"
"""
type buckets_aggregate_fields {
  avg: buckets_avg_fields
  count(columns: [buckets_select_column!], distinct: Boolean): Int!
  max: buckets_max_fields
  min: buckets_min_fields
  stddev: buckets_stddev_fields
  stddev_pop: buckets_stddev_pop_fields
  stddev_samp: buckets_stddev_samp_fields
  sum: buckets_sum_fields
  var_pop: buckets_var_pop_fields
  var_samp: buckets_var_samp_fields
  variance: buckets_variance_fields
}

"""aggregate avg on columns"""
type buckets_avg_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'.
"""
input buckets_bool_exp {
  _and: [buckets_bool_exp!]
  _not: buckets_bool_exp
  _or: [buckets_bool_exp!]
  cacheControl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  downloadExpiration: Int_comparison_exp
  files: files_bool_exp
  files_aggregate: files_aggregate_bool_exp
  id: String_comparison_exp
  maxUploadFileSize: Int_comparison_exp
  minUploadFileSize: Int_comparison_exp
  presignedUrlsEnabled: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets"
"""
enum buckets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  buckets_pkey
}

"""
input type for incrementing numeric columns in table "storage.buckets"
"""
input buckets_inc_input {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
input type for inserting data into table "storage.buckets"
"""
input buckets_insert_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  files: files_arr_rel_insert_input
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type buckets_max_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type buckets_min_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.buckets"
"""
type buckets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [buckets!]!
}

"""
input type for inserting object relation for remote table "storage.buckets"
"""
input buckets_obj_rel_insert_input {
  data: buckets_insert_input!

  """upsert condition"""
  on_conflict: buckets_on_conflict
}

"""
on_conflict condition type for table "storage.buckets"
"""
input buckets_on_conflict {
  constraint: buckets_constraint!
  update_columns: [buckets_update_column!]! = []
  where: buckets_bool_exp
}

"""Ordering options when selecting data from "storage.buckets"."""
input buckets_order_by {
  cacheControl: order_by
  createdAt: order_by
  downloadExpiration: order_by
  files_aggregate: files_aggregate_order_by
  id: order_by
  maxUploadFileSize: order_by
  minUploadFileSize: order_by
  presignedUrlsEnabled: order_by
  updatedAt: order_by
}

"""primary key columns input for table: storage.buckets"""
input buckets_pk_columns_input {
  id: String!
}

"""
select columns of table "storage.buckets"
"""
enum buckets_select_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

"""
input type for updating data in table "storage.buckets"
"""
input buckets_set_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type buckets_stddev_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_pop on columns"""
type buckets_stddev_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_samp on columns"""
type buckets_stddev_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Streaming cursor of the table "buckets"
"""
input buckets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: buckets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input buckets_stream_cursor_value_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type buckets_sum_fields {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
update columns of table "storage.buckets"
"""
enum buckets_update_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

input buckets_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: buckets_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: buckets_set_input
  where: buckets_bool_exp!
}

"""aggregate var_pop on columns"""
type buckets_var_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate var_samp on columns"""
type buckets_var_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate variance on columns"""
type buckets_variance_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""
columns and relationships of "companies"
"""
type companies {
  address: String

  """An object relationship"""
  companySize: company_sizes
  created_at: timestamptz
  email: String

  """An object relationship"""
  employer: users!
  employer_id: uuid!
  id: uuid!

  """An array relationship"""
  jobs(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): [jobs!]!

  """An aggregate relationship"""
  jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): jobs_aggregate!
  logoUrl: String
  name: String!
  size: String
  telephone: String
  updated_at: timestamptz
}

"""
aggregated selection of "companies"
"""
type companies_aggregate {
  aggregate: companies_aggregate_fields
  nodes: [companies!]!
}

"""
aggregate fields of "companies"
"""
type companies_aggregate_fields {
  count(columns: [companies_select_column!], distinct: Boolean): Int!
  max: companies_max_fields
  min: companies_min_fields
}

"""
Boolean expression to filter rows from the table "companies". All fields are combined with a logical 'AND'.
"""
input companies_bool_exp {
  _and: [companies_bool_exp!]
  _not: companies_bool_exp
  _or: [companies_bool_exp!]
  address: String_comparison_exp
  companySize: company_sizes_bool_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  employer: users_bool_exp
  employer_id: uuid_comparison_exp
  id: uuid_comparison_exp
  jobs: jobs_bool_exp
  jobs_aggregate: jobs_aggregate_bool_exp
  logoUrl: String_comparison_exp
  name: String_comparison_exp
  size: String_comparison_exp
  telephone: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "companies"
"""
enum companies_constraint {
  """
  unique or primary key constraint on columns "employer_id"
  """
  companies_employer_id_key

  """
  unique or primary key constraint on columns "id"
  """
  companies_pkey
}

"""
input type for inserting data into table "companies"
"""
input companies_insert_input {
  address: String
  companySize: company_sizes_obj_rel_insert_input
  created_at: timestamptz
  email: String
  employer: users_obj_rel_insert_input
  employer_id: uuid
  id: uuid
  jobs: jobs_arr_rel_insert_input
  logoUrl: String
  name: String
  size: String
  telephone: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type companies_max_fields {
  address: String
  created_at: timestamptz
  email: String
  employer_id: uuid
  id: uuid
  logoUrl: String
  name: String
  size: String
  telephone: String
  updated_at: timestamptz
}

"""aggregate min on columns"""
type companies_min_fields {
  address: String
  created_at: timestamptz
  email: String
  employer_id: uuid
  id: uuid
  logoUrl: String
  name: String
  size: String
  telephone: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "companies"
"""
type companies_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [companies!]!
}

"""
input type for inserting object relation for remote table "companies"
"""
input companies_obj_rel_insert_input {
  data: companies_insert_input!

  """upsert condition"""
  on_conflict: companies_on_conflict
}

"""
on_conflict condition type for table "companies"
"""
input companies_on_conflict {
  constraint: companies_constraint!
  update_columns: [companies_update_column!]! = []
  where: companies_bool_exp
}

"""Ordering options when selecting data from "companies"."""
input companies_order_by {
  address: order_by
  companySize: company_sizes_order_by
  created_at: order_by
  email: order_by
  employer: users_order_by
  employer_id: order_by
  id: order_by
  jobs_aggregate: jobs_aggregate_order_by
  logoUrl: order_by
  name: order_by
  size: order_by
  telephone: order_by
  updated_at: order_by
}

"""primary key columns input for table: companies"""
input companies_pk_columns_input {
  id: uuid!
}

"""
select columns of table "companies"
"""
enum companies_select_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  employer_id

  """column name"""
  id

  """column name"""
  logoUrl

  """column name"""
  name

  """column name"""
  size

  """column name"""
  telephone

  """column name"""
  updated_at
}

"""
input type for updating data in table "companies"
"""
input companies_set_input {
  address: String
  created_at: timestamptz
  email: String
  employer_id: uuid
  id: uuid
  logoUrl: String
  name: String
  size: String
  telephone: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "companies"
"""
input companies_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: companies_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input companies_stream_cursor_value_input {
  address: String
  created_at: timestamptz
  email: String
  employer_id: uuid
  id: uuid
  logoUrl: String
  name: String
  size: String
  telephone: String
  updated_at: timestamptz
}

"""
update columns of table "companies"
"""
enum companies_update_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  email

  """column name"""
  employer_id

  """column name"""
  id

  """column name"""
  logoUrl

  """column name"""
  name

  """column name"""
  size

  """column name"""
  telephone

  """column name"""
  updated_at
}

input companies_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: companies_set_input
  where: companies_bool_exp!
}

"""
columns and relationships of "company_sizes"
"""
type company_sizes {
  size: String!
}

"""
aggregated selection of "company_sizes"
"""
type company_sizes_aggregate {
  aggregate: company_sizes_aggregate_fields
  nodes: [company_sizes!]!
}

"""
aggregate fields of "company_sizes"
"""
type company_sizes_aggregate_fields {
  count(columns: [company_sizes_select_column!], distinct: Boolean): Int!
  max: company_sizes_max_fields
  min: company_sizes_min_fields
}

"""
Boolean expression to filter rows from the table "company_sizes". All fields are combined with a logical 'AND'.
"""
input company_sizes_bool_exp {
  _and: [company_sizes_bool_exp!]
  _not: company_sizes_bool_exp
  _or: [company_sizes_bool_exp!]
  size: String_comparison_exp
}

"""
unique or primary key constraints on table "company_sizes"
"""
enum company_sizes_constraint {
  """
  unique or primary key constraint on columns "size"
  """
  company_sizes_pkey
}

"""
input type for inserting data into table "company_sizes"
"""
input company_sizes_insert_input {
  size: String
}

"""aggregate max on columns"""
type company_sizes_max_fields {
  size: String
}

"""aggregate min on columns"""
type company_sizes_min_fields {
  size: String
}

"""
response of any mutation on the table "company_sizes"
"""
type company_sizes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [company_sizes!]!
}

"""
input type for inserting object relation for remote table "company_sizes"
"""
input company_sizes_obj_rel_insert_input {
  data: company_sizes_insert_input!

  """upsert condition"""
  on_conflict: company_sizes_on_conflict
}

"""
on_conflict condition type for table "company_sizes"
"""
input company_sizes_on_conflict {
  constraint: company_sizes_constraint!
  update_columns: [company_sizes_update_column!]! = []
  where: company_sizes_bool_exp
}

"""Ordering options when selecting data from "company_sizes"."""
input company_sizes_order_by {
  size: order_by
}

"""primary key columns input for table: company_sizes"""
input company_sizes_pk_columns_input {
  size: String!
}

"""
select columns of table "company_sizes"
"""
enum company_sizes_select_column {
  """column name"""
  size
}

"""
input type for updating data in table "company_sizes"
"""
input company_sizes_set_input {
  size: String
}

"""
Streaming cursor of the table "company_sizes"
"""
input company_sizes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: company_sizes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input company_sizes_stream_cursor_value_input {
  size: String
}

"""
update columns of table "company_sizes"
"""
enum company_sizes_update_column {
  """column name"""
  size
}

input company_sizes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: company_sizes_set_input
  where: company_sizes_bool_exp!
}

"""
fields of action: "createMyProfile"
"""
type createMyProfile {
  """the time at which this action was created"""
  created_at: timestamptz!

  """errors related to the invocation"""
  errors: json

  """the unique id of an action"""
  id: uuid!

  """the output fields of this action"""
  output: Profile
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "employments"
"""
type employments {
  company_name: String!
  end_date: String
  id: uuid!
  location: String
  position: String

  """An object relationship"""
  profile: profiles
  profile_id: uuid
  start_date: String
}

"""
aggregated selection of "employments"
"""
type employments_aggregate {
  aggregate: employments_aggregate_fields
  nodes: [employments!]!
}

input employments_aggregate_bool_exp {
  count: employments_aggregate_bool_exp_count
}

input employments_aggregate_bool_exp_count {
  arguments: [employments_select_column!]
  distinct: Boolean
  filter: employments_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "employments"
"""
type employments_aggregate_fields {
  count(columns: [employments_select_column!], distinct: Boolean): Int!
  max: employments_max_fields
  min: employments_min_fields
}

"""
order by aggregate values of table "employments"
"""
input employments_aggregate_order_by {
  count: order_by
  max: employments_max_order_by
  min: employments_min_order_by
}

"""
input type for inserting array relation for remote table "employments"
"""
input employments_arr_rel_insert_input {
  data: [employments_insert_input!]!

  """upsert condition"""
  on_conflict: employments_on_conflict
}

"""
Boolean expression to filter rows from the table "employments". All fields are combined with a logical 'AND'.
"""
input employments_bool_exp {
  _and: [employments_bool_exp!]
  _not: employments_bool_exp
  _or: [employments_bool_exp!]
  company_name: String_comparison_exp
  end_date: String_comparison_exp
  id: uuid_comparison_exp
  location: String_comparison_exp
  position: String_comparison_exp
  profile: profiles_bool_exp
  profile_id: uuid_comparison_exp
  start_date: String_comparison_exp
}

"""
unique or primary key constraints on table "employments"
"""
enum employments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  employments_pkey
}

"""
input type for inserting data into table "employments"
"""
input employments_insert_input {
  company_name: String
  end_date: String
  id: uuid
  location: String
  position: String
  profile: profiles_obj_rel_insert_input
  profile_id: uuid
  start_date: String
}

"""aggregate max on columns"""
type employments_max_fields {
  company_name: String
  end_date: String
  id: uuid
  location: String
  position: String
  profile_id: uuid
  start_date: String
}

"""
order by max() on columns of table "employments"
"""
input employments_max_order_by {
  company_name: order_by
  end_date: order_by
  id: order_by
  location: order_by
  position: order_by
  profile_id: order_by
  start_date: order_by
}

"""aggregate min on columns"""
type employments_min_fields {
  company_name: String
  end_date: String
  id: uuid
  location: String
  position: String
  profile_id: uuid
  start_date: String
}

"""
order by min() on columns of table "employments"
"""
input employments_min_order_by {
  company_name: order_by
  end_date: order_by
  id: order_by
  location: order_by
  position: order_by
  profile_id: order_by
  start_date: order_by
}

"""
response of any mutation on the table "employments"
"""
type employments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [employments!]!
}

"""
on_conflict condition type for table "employments"
"""
input employments_on_conflict {
  constraint: employments_constraint!
  update_columns: [employments_update_column!]! = []
  where: employments_bool_exp
}

"""Ordering options when selecting data from "employments"."""
input employments_order_by {
  company_name: order_by
  end_date: order_by
  id: order_by
  location: order_by
  position: order_by
  profile: profiles_order_by
  profile_id: order_by
  start_date: order_by
}

"""primary key columns input for table: employments"""
input employments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "employments"
"""
enum employments_select_column {
  """column name"""
  company_name

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  location

  """column name"""
  position

  """column name"""
  profile_id

  """column name"""
  start_date
}

"""
input type for updating data in table "employments"
"""
input employments_set_input {
  company_name: String
  end_date: String
  id: uuid
  location: String
  position: String
  profile_id: uuid
  start_date: String
}

"""
Streaming cursor of the table "employments"
"""
input employments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: employments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input employments_stream_cursor_value_input {
  company_name: String
  end_date: String
  id: uuid
  location: String
  position: String
  profile_id: uuid
  start_date: String
}

"""
update columns of table "employments"
"""
enum employments_update_column {
  """column name"""
  company_name

  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  location

  """column name"""
  position

  """column name"""
  profile_id

  """column name"""
  start_date
}

input employments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: employments_set_input
  where: employments_bool_exp!
}

"""
columns and relationships of "storage.files"
"""
type files {
  """An object relationship"""
  bucket: buckets!
  bucketId: String!
  createdAt: timestamptz!
  etag: String
  id: uuid!
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz!
  uploadedByUserId: uuid
}

"""
aggregated selection of "storage.files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

input files_aggregate_bool_exp {
  bool_and: files_aggregate_bool_exp_bool_and
  bool_or: files_aggregate_bool_exp_bool_or
  count: files_aggregate_bool_exp_count
}

input files_aggregate_bool_exp_bool_and {
  arguments: files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_bool_or {
  arguments: files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_count {
  arguments: [files_select_column!]
  distinct: Boolean
  filter: files_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "storage.files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""
input type for inserting array relation for remote table "storage.files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  size: Float
}

"""
order by avg() on columns of table "storage.files"
"""
input files_avg_order_by {
  size: order_by
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  bucket: buckets_bool_exp
  bucketId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  isUploaded: Boolean_comparison_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
input type for incrementing numeric columns in table "storage.files"
"""
input files_inc_input {
  size: Int
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
  bucket: buckets_obj_rel_insert_input
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate max on columns"""
type files_max_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by max() on columns of table "storage.files"
"""
input files_max_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by min() on columns of table "storage.files"
"""
input files_min_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "storage.files"."""
input files_order_by {
  bucket: buckets_order_by
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  isUploaded: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""primary key columns input for table: storage.files"""
input files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""
select "files_aggregate_bool_exp_bool_and_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isUploaded
}

"""
select "files_aggregate_bool_exp_bool_or_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isUploaded
}

"""
input type for updating data in table "storage.files"
"""
input files_set_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  size: Float
}

"""
order by stddev() on columns of table "storage.files"
"""
input files_stddev_order_by {
  size: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  size: Float
}

"""
order by stddev_pop() on columns of table "storage.files"
"""
input files_stddev_pop_order_by {
  size: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  size: Float
}

"""
order by stddev_samp() on columns of table "storage.files"
"""
input files_stddev_samp_order_by {
  size: order_by
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate sum on columns"""
type files_sum_fields {
  size: Int
}

"""
order by sum() on columns of table "storage.files"
"""
input files_sum_order_by {
  size: order_by
}

"""
update columns of table "storage.files"
"""
enum files_update_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

input files_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  size: Float
}

"""
order by var_pop() on columns of table "storage.files"
"""
input files_var_pop_order_by {
  size: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  size: Float
}

"""
order by var_samp() on columns of table "storage.files"
"""
input files_var_samp_order_by {
  size: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  size: Float
}

"""
order by variance() on columns of table "storage.files"
"""
input files_variance_order_by {
  size: order_by
}

"""
columns and relationships of "job_types"
"""
type job_types {
  type_display: String
  type_name: String!
}

"""
aggregated selection of "job_types"
"""
type job_types_aggregate {
  aggregate: job_types_aggregate_fields
  nodes: [job_types!]!
}

"""
aggregate fields of "job_types"
"""
type job_types_aggregate_fields {
  count(columns: [job_types_select_column!], distinct: Boolean): Int!
  max: job_types_max_fields
  min: job_types_min_fields
}

"""
Boolean expression to filter rows from the table "job_types". All fields are combined with a logical 'AND'.
"""
input job_types_bool_exp {
  _and: [job_types_bool_exp!]
  _not: job_types_bool_exp
  _or: [job_types_bool_exp!]
  type_display: String_comparison_exp
  type_name: String_comparison_exp
}

"""
unique or primary key constraints on table "job_types"
"""
enum job_types_constraint {
  """
  unique or primary key constraint on columns "type_name"
  """
  job_types_pkey
}

"""
input type for inserting data into table "job_types"
"""
input job_types_insert_input {
  type_display: String
  type_name: String
}

"""aggregate max on columns"""
type job_types_max_fields {
  type_display: String
  type_name: String
}

"""aggregate min on columns"""
type job_types_min_fields {
  type_display: String
  type_name: String
}

"""
response of any mutation on the table "job_types"
"""
type job_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [job_types!]!
}

"""
input type for inserting object relation for remote table "job_types"
"""
input job_types_obj_rel_insert_input {
  data: job_types_insert_input!

  """upsert condition"""
  on_conflict: job_types_on_conflict
}

"""
on_conflict condition type for table "job_types"
"""
input job_types_on_conflict {
  constraint: job_types_constraint!
  update_columns: [job_types_update_column!]! = []
  where: job_types_bool_exp
}

"""Ordering options when selecting data from "job_types"."""
input job_types_order_by {
  type_display: order_by
  type_name: order_by
}

"""primary key columns input for table: job_types"""
input job_types_pk_columns_input {
  type_name: String!
}

"""
select columns of table "job_types"
"""
enum job_types_select_column {
  """column name"""
  type_display

  """column name"""
  type_name
}

"""
input type for updating data in table "job_types"
"""
input job_types_set_input {
  type_display: String
  type_name: String
}

"""
Streaming cursor of the table "job_types"
"""
input job_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: job_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input job_types_stream_cursor_value_input {
  type_display: String
  type_name: String
}

"""
update columns of table "job_types"
"""
enum job_types_update_column {
  """column name"""
  type_display

  """column name"""
  type_name
}

input job_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: job_types_set_input
  where: job_types_bool_exp!
}

"""
columns and relationships of "jobs"
"""
type jobs {
  """An array relationship"""
  applications(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!

  """An aggregate relationship"""
  applications_aggregate(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): applications_aggregate!

  """An object relationship"""
  company: companies!
  company_id: uuid!
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid!
  is_active: Boolean

  """An object relationship"""
  jobType: job_types
  location: String

  """An object relationship"""
  locationType: location_types
  title: String!
  type: String
  updated_at: timestamptz
}

"""
aggregated selection of "jobs"
"""
type jobs_aggregate {
  aggregate: jobs_aggregate_fields
  nodes: [jobs!]!
}

input jobs_aggregate_bool_exp {
  bool_and: jobs_aggregate_bool_exp_bool_and
  bool_or: jobs_aggregate_bool_exp_bool_or
  count: jobs_aggregate_bool_exp_count
}

input jobs_aggregate_bool_exp_bool_and {
  arguments: jobs_select_column_jobs_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: jobs_bool_exp
  predicate: Boolean_comparison_exp!
}

input jobs_aggregate_bool_exp_bool_or {
  arguments: jobs_select_column_jobs_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: jobs_bool_exp
  predicate: Boolean_comparison_exp!
}

input jobs_aggregate_bool_exp_count {
  arguments: [jobs_select_column!]
  distinct: Boolean
  filter: jobs_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "jobs"
"""
type jobs_aggregate_fields {
  count(columns: [jobs_select_column!], distinct: Boolean): Int!
  max: jobs_max_fields
  min: jobs_min_fields
}

"""
order by aggregate values of table "jobs"
"""
input jobs_aggregate_order_by {
  count: order_by
  max: jobs_max_order_by
  min: jobs_min_order_by
}

"""
input type for inserting array relation for remote table "jobs"
"""
input jobs_arr_rel_insert_input {
  data: [jobs_insert_input!]!

  """upsert condition"""
  on_conflict: jobs_on_conflict
}

"""
Boolean expression to filter rows from the table "jobs". All fields are combined with a logical 'AND'.
"""
input jobs_bool_exp {
  _and: [jobs_bool_exp!]
  _not: jobs_bool_exp
  _or: [jobs_bool_exp!]
  applications: applications_bool_exp
  applications_aggregate: applications_aggregate_bool_exp
  company: companies_bool_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  is_active: Boolean_comparison_exp
  jobType: job_types_bool_exp
  location: String_comparison_exp
  locationType: location_types_bool_exp
  title: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "jobs"
"""
enum jobs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  jobs_pkey
}

"""
input type for inserting data into table "jobs"
"""
input jobs_insert_input {
  applications: applications_arr_rel_insert_input
  company: companies_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_active: Boolean
  jobType: job_types_obj_rel_insert_input
  location: String
  locationType: location_types_obj_rel_insert_input
  title: String
  type: String
  updated_at: timestamptz
}

"""aggregate max on columns"""
type jobs_max_fields {
  company_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  location: String
  title: String
  type: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "jobs"
"""
input jobs_max_order_by {
  company_id: order_by
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  location: order_by
  title: order_by
  type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type jobs_min_fields {
  company_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  location: String
  title: String
  type: String
  updated_at: timestamptz
}

"""
order by min() on columns of table "jobs"
"""
input jobs_min_order_by {
  company_id: order_by
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  location: order_by
  title: order_by
  type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "jobs"
"""
type jobs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [jobs!]!
}

"""
input type for inserting object relation for remote table "jobs"
"""
input jobs_obj_rel_insert_input {
  data: jobs_insert_input!

  """upsert condition"""
  on_conflict: jobs_on_conflict
}

"""
on_conflict condition type for table "jobs"
"""
input jobs_on_conflict {
  constraint: jobs_constraint!
  update_columns: [jobs_update_column!]! = []
  where: jobs_bool_exp
}

"""Ordering options when selecting data from "jobs"."""
input jobs_order_by {
  applications_aggregate: applications_aggregate_order_by
  company: companies_order_by
  company_id: order_by
  created_at: order_by
  deleted_at: order_by
  description: order_by
  id: order_by
  is_active: order_by
  jobType: job_types_order_by
  location: order_by
  locationType: location_types_order_by
  title: order_by
  type: order_by
  updated_at: order_by
}

"""primary key columns input for table: jobs"""
input jobs_pk_columns_input {
  id: uuid!
}

"""
select columns of table "jobs"
"""
enum jobs_select_column {
  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  location

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at
}

"""
select "jobs_aggregate_bool_exp_bool_and_arguments_columns" columns of table "jobs"
"""
enum jobs_select_column_jobs_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  is_active
}

"""
select "jobs_aggregate_bool_exp_bool_or_arguments_columns" columns of table "jobs"
"""
enum jobs_select_column_jobs_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  is_active
}

"""
input type for updating data in table "jobs"
"""
input jobs_set_input {
  company_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_active: Boolean
  location: String
  title: String
  type: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "jobs"
"""
input jobs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: jobs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input jobs_stream_cursor_value_input {
  company_id: uuid
  created_at: timestamptz
  deleted_at: timestamptz
  description: String
  id: uuid
  is_active: Boolean
  location: String
  title: String
  type: String
  updated_at: timestamptz
}

"""
update columns of table "jobs"
"""
enum jobs_update_column {
  """column name"""
  company_id

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  is_active

  """column name"""
  location

  """column name"""
  title

  """column name"""
  type

  """column name"""
  updated_at
}

input jobs_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: jobs_set_input
  where: jobs_bool_exp!
}

scalar json

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "location_types"
"""
type location_types {
  location: String!
}

"""
aggregated selection of "location_types"
"""
type location_types_aggregate {
  aggregate: location_types_aggregate_fields
  nodes: [location_types!]!
}

"""
aggregate fields of "location_types"
"""
type location_types_aggregate_fields {
  count(columns: [location_types_select_column!], distinct: Boolean): Int!
  max: location_types_max_fields
  min: location_types_min_fields
}

"""
Boolean expression to filter rows from the table "location_types". All fields are combined with a logical 'AND'.
"""
input location_types_bool_exp {
  _and: [location_types_bool_exp!]
  _not: location_types_bool_exp
  _or: [location_types_bool_exp!]
  location: String_comparison_exp
}

"""
unique or primary key constraints on table "location_types"
"""
enum location_types_constraint {
  """
  unique or primary key constraint on columns "location"
  """
  location_types_pkey
}

"""
input type for inserting data into table "location_types"
"""
input location_types_insert_input {
  location: String
}

"""aggregate max on columns"""
type location_types_max_fields {
  location: String
}

"""aggregate min on columns"""
type location_types_min_fields {
  location: String
}

"""
response of any mutation on the table "location_types"
"""
type location_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [location_types!]!
}

"""
input type for inserting object relation for remote table "location_types"
"""
input location_types_obj_rel_insert_input {
  data: location_types_insert_input!

  """upsert condition"""
  on_conflict: location_types_on_conflict
}

"""
on_conflict condition type for table "location_types"
"""
input location_types_on_conflict {
  constraint: location_types_constraint!
  update_columns: [location_types_update_column!]! = []
  where: location_types_bool_exp
}

"""Ordering options when selecting data from "location_types"."""
input location_types_order_by {
  location: order_by
}

"""primary key columns input for table: location_types"""
input location_types_pk_columns_input {
  location: String!
}

"""
select columns of table "location_types"
"""
enum location_types_select_column {
  """column name"""
  location
}

"""
input type for updating data in table "location_types"
"""
input location_types_set_input {
  location: String
}

"""
Streaming cursor of the table "location_types"
"""
input location_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: location_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input location_types_stream_cursor_value_input {
  location: String
}

"""
update columns of table "location_types"
"""
enum location_types_update_column {
  """column name"""
  location
}

input location_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: location_types_set_input
  where: location_types_bool_exp!
}

"""mutation root"""
type mutation_root {
  addUserRole(role: String!, user_id: String!): Profile

  """Apply for a job"""
  applyJob(args: JobUserInput!): uuid!
  createMyProfile(user_id: String!): uuid!

  """
  delete single row from the table: "auth.providers"
  """
  deleteAuthProvider(id: String!): authProviders

  """
  delete single row from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequest(id: uuid!): authProviderRequests

  """
  delete data from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequests(
    """filter the rows which have to be deleted"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  delete data from the table: "auth.providers"
  """
  deleteAuthProviders(
    """filter the rows which have to be deleted"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  delete data from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshTokens(
    """filter the rows which have to be deleted"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  deleteAuthRole(role: String!): authRoles

  """
  delete data from the table: "auth.roles"
  """
  deleteAuthRoles(
    """filter the rows which have to be deleted"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  delete single row from the table: "auth.user_providers"
  """
  deleteAuthUserProvider(id: uuid!): authUserProviders

  """
  delete data from the table: "auth.user_providers"
  """
  deleteAuthUserProviders(
    """filter the rows which have to be deleted"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  delete single row from the table: "auth.user_roles"
  """
  deleteAuthUserRole(id: uuid!): authUserRoles

  """
  delete data from the table: "auth.user_roles"
  """
  deleteAuthUserRoles(
    """filter the rows which have to be deleted"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  delete single row from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  delete data from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKeys(
    """filter the rows which have to be deleted"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  delete single row from the table: "storage.buckets"
  """
  deleteBucket(id: String!): buckets

  """
  delete data from the table: "storage.buckets"
  """
  deleteBuckets(
    """filter the rows which have to be deleted"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  delete single row from the table: "storage.files"
  """
  deleteFile(id: uuid!): files

  """
  delete data from the table: "storage.files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "auth.users"
  """
  deleteUser(id: uuid!): users

  """
  delete data from the table: "auth.users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete data from the table: "application_status"
  """
  delete_application_status(
    """filter the rows which have to be deleted"""
    where: application_status_bool_exp!
  ): application_status_mutation_response

  """
  delete single row from the table: "application_status"
  """
  delete_application_status_by_pk(status: String!): application_status

  """
  delete data from the table: "applications"
  """
  delete_applications(
    """filter the rows which have to be deleted"""
    where: applications_bool_exp!
  ): applications_mutation_response

  """
  delete single row from the table: "applications"
  """
  delete_applications_by_pk(job_id: uuid!, user_id: uuid!): applications

  """
  delete data from the table: "companies"
  """
  delete_companies(
    """filter the rows which have to be deleted"""
    where: companies_bool_exp!
  ): companies_mutation_response

  """
  delete single row from the table: "companies"
  """
  delete_companies_by_pk(id: uuid!): companies

  """
  delete data from the table: "company_sizes"
  """
  delete_company_sizes(
    """filter the rows which have to be deleted"""
    where: company_sizes_bool_exp!
  ): company_sizes_mutation_response

  """
  delete single row from the table: "company_sizes"
  """
  delete_company_sizes_by_pk(size: String!): company_sizes

  """
  delete data from the table: "employments"
  """
  delete_employments(
    """filter the rows which have to be deleted"""
    where: employments_bool_exp!
  ): employments_mutation_response

  """
  delete single row from the table: "employments"
  """
  delete_employments_by_pk(id: uuid!): employments

  """
  delete data from the table: "job_types"
  """
  delete_job_types(
    """filter the rows which have to be deleted"""
    where: job_types_bool_exp!
  ): job_types_mutation_response

  """
  delete single row from the table: "job_types"
  """
  delete_job_types_by_pk(type_name: String!): job_types

  """
  delete data from the table: "jobs"
  """
  delete_jobs(
    """filter the rows which have to be deleted"""
    where: jobs_bool_exp!
  ): jobs_mutation_response

  """
  delete single row from the table: "jobs"
  """
  delete_jobs_by_pk(id: uuid!): jobs

  """
  delete data from the table: "location_types"
  """
  delete_location_types(
    """filter the rows which have to be deleted"""
    where: location_types_bool_exp!
  ): location_types_mutation_response

  """
  delete single row from the table: "location_types"
  """
  delete_location_types_by_pk(location: String!): location_types

  """
  delete data from the table: "profile_types"
  """
  delete_profile_types(
    """filter the rows which have to be deleted"""
    where: profile_types_bool_exp!
  ): profile_types_mutation_response

  """
  delete single row from the table: "profile_types"
  """
  delete_profile_types_by_pk(type_name: String!): profile_types

  """
  delete data from the table: "profiles"
  """
  delete_profiles(
    """filter the rows which have to be deleted"""
    where: profiles_bool_exp!
  ): profiles_mutation_response

  """
  delete single row from the table: "profiles"
  """
  delete_profiles_by_pk(id: uuid!): profiles

  """
  insert a single row into the table: "auth.providers"
  """
  insertAuthProvider(
    """the row to be inserted"""
    object: authProviders_insert_input!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders

  """
  insert a single row into the table: "auth.provider_requests"
  """
  insertAuthProviderRequest(
    """the row to be inserted"""
    object: authProviderRequests_insert_input!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests

  """
  insert data into the table: "auth.provider_requests"
  """
  insertAuthProviderRequests(
    """the rows to be inserted"""
    objects: [authProviderRequests_insert_input!]!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests_mutation_response

  """
  insert data into the table: "auth.providers"
  """
  insertAuthProviders(
    """the rows to be inserted"""
    objects: [authProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshToken(
    """the row to be inserted"""
    object: authRefreshTokens_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshTokens(
    """the rows to be inserted"""
    objects: [authRefreshTokens_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insertAuthRole(
    """the row to be inserted"""
    object: authRoles_insert_input!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles

  """
  insert data into the table: "auth.roles"
  """
  insertAuthRoles(
    """the rows to be inserted"""
    objects: [authRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles_mutation_response

  """
  insert a single row into the table: "auth.user_providers"
  """
  insertAuthUserProvider(
    """the row to be inserted"""
    object: authUserProviders_insert_input!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders

  """
  insert data into the table: "auth.user_providers"
  """
  insertAuthUserProviders(
    """the rows to be inserted"""
    objects: [authUserProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders_mutation_response

  """
  insert a single row into the table: "auth.user_roles"
  """
  insertAuthUserRole(
    """the row to be inserted"""
    object: authUserRoles_insert_input!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles

  """
  insert data into the table: "auth.user_roles"
  """
  insertAuthUserRoles(
    """the rows to be inserted"""
    objects: [authUserRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles_mutation_response

  """
  insert a single row into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKey(
    """the row to be inserted"""
    object: authUserSecurityKeys_insert_input!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys

  """
  insert data into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKeys(
    """the rows to be inserted"""
    objects: [authUserSecurityKeys_insert_input!]!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys_mutation_response

  """
  insert a single row into the table: "storage.buckets"
  """
  insertBucket(
    """the row to be inserted"""
    object: buckets_insert_input!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets

  """
  insert data into the table: "storage.buckets"
  """
  insertBuckets(
    """the rows to be inserted"""
    objects: [buckets_insert_input!]!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets_mutation_response

  """
  insert a single row into the table: "storage.files"
  """
  insertFile(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "storage.files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "auth.users"
  """
  insertUser(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "auth.users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert data into the table: "application_status"
  """
  insert_application_status(
    """the rows to be inserted"""
    objects: [application_status_insert_input!]!

    """upsert condition"""
    on_conflict: application_status_on_conflict
  ): application_status_mutation_response

  """
  insert a single row into the table: "application_status"
  """
  insert_application_status_one(
    """the row to be inserted"""
    object: application_status_insert_input!

    """upsert condition"""
    on_conflict: application_status_on_conflict
  ): application_status

  """
  insert data into the table: "applications"
  """
  insert_applications(
    """the rows to be inserted"""
    objects: [applications_insert_input!]!

    """upsert condition"""
    on_conflict: applications_on_conflict
  ): applications_mutation_response

  """
  insert a single row into the table: "applications"
  """
  insert_applications_one(
    """the row to be inserted"""
    object: applications_insert_input!

    """upsert condition"""
    on_conflict: applications_on_conflict
  ): applications

  """
  insert data into the table: "companies"
  """
  insert_companies(
    """the rows to be inserted"""
    objects: [companies_insert_input!]!

    """upsert condition"""
    on_conflict: companies_on_conflict
  ): companies_mutation_response

  """
  insert a single row into the table: "companies"
  """
  insert_companies_one(
    """the row to be inserted"""
    object: companies_insert_input!

    """upsert condition"""
    on_conflict: companies_on_conflict
  ): companies

  """
  insert data into the table: "company_sizes"
  """
  insert_company_sizes(
    """the rows to be inserted"""
    objects: [company_sizes_insert_input!]!

    """upsert condition"""
    on_conflict: company_sizes_on_conflict
  ): company_sizes_mutation_response

  """
  insert a single row into the table: "company_sizes"
  """
  insert_company_sizes_one(
    """the row to be inserted"""
    object: company_sizes_insert_input!

    """upsert condition"""
    on_conflict: company_sizes_on_conflict
  ): company_sizes

  """
  insert data into the table: "employments"
  """
  insert_employments(
    """the rows to be inserted"""
    objects: [employments_insert_input!]!

    """upsert condition"""
    on_conflict: employments_on_conflict
  ): employments_mutation_response

  """
  insert a single row into the table: "employments"
  """
  insert_employments_one(
    """the row to be inserted"""
    object: employments_insert_input!

    """upsert condition"""
    on_conflict: employments_on_conflict
  ): employments

  """
  insert data into the table: "job_types"
  """
  insert_job_types(
    """the rows to be inserted"""
    objects: [job_types_insert_input!]!

    """upsert condition"""
    on_conflict: job_types_on_conflict
  ): job_types_mutation_response

  """
  insert a single row into the table: "job_types"
  """
  insert_job_types_one(
    """the row to be inserted"""
    object: job_types_insert_input!

    """upsert condition"""
    on_conflict: job_types_on_conflict
  ): job_types

  """
  insert data into the table: "jobs"
  """
  insert_jobs(
    """the rows to be inserted"""
    objects: [jobs_insert_input!]!

    """upsert condition"""
    on_conflict: jobs_on_conflict
  ): jobs_mutation_response

  """
  insert a single row into the table: "jobs"
  """
  insert_jobs_one(
    """the row to be inserted"""
    object: jobs_insert_input!

    """upsert condition"""
    on_conflict: jobs_on_conflict
  ): jobs

  """
  insert data into the table: "location_types"
  """
  insert_location_types(
    """the rows to be inserted"""
    objects: [location_types_insert_input!]!

    """upsert condition"""
    on_conflict: location_types_on_conflict
  ): location_types_mutation_response

  """
  insert a single row into the table: "location_types"
  """
  insert_location_types_one(
    """the row to be inserted"""
    object: location_types_insert_input!

    """upsert condition"""
    on_conflict: location_types_on_conflict
  ): location_types

  """
  insert data into the table: "profile_types"
  """
  insert_profile_types(
    """the rows to be inserted"""
    objects: [profile_types_insert_input!]!

    """upsert condition"""
    on_conflict: profile_types_on_conflict
  ): profile_types_mutation_response

  """
  insert a single row into the table: "profile_types"
  """
  insert_profile_types_one(
    """the row to be inserted"""
    object: profile_types_insert_input!

    """upsert condition"""
    on_conflict: profile_types_on_conflict
  ): profile_types

  """
  insert data into the table: "profiles"
  """
  insert_profiles(
    """the rows to be inserted"""
    objects: [profiles_insert_input!]!

    """upsert condition"""
    on_conflict: profiles_on_conflict
  ): profiles_mutation_response

  """
  insert a single row into the table: "profiles"
  """
  insert_profiles_one(
    """the row to be inserted"""
    object: profiles_insert_input!

    """upsert condition"""
    on_conflict: profiles_on_conflict
  ): profiles

  """Create a Job Post"""
  postJob(arg: PostJobInput!): Job
  registerAsEmployer(arg: EmployerProfileInput!): uuid!

  """Register as job seeker"""
  registerAsSeeker(arg: SeekerProfileInput!): uuid!
  setDefaultRole(role: String!, user_id: String!): Profile

  """
  update single row of the table: "auth.providers"
  """
  updateAuthProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input
    pk_columns: authProviders_pk_columns_input!
  ): authProviders

  """
  update single row of the table: "auth.provider_requests"
  """
  updateAuthProviderRequest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input
    pk_columns: authProviderRequests_pk_columns_input!
  ): authProviderRequests

  """
  update data of the table: "auth.provider_requests"
  """
  updateAuthProviderRequests(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input

    """filter the rows which have to be updated"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  update data of the table: "auth.providers"
  """
  updateAuthProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input

    """filter the rows which have to be updated"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshToken(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input
    pk_columns: authRefreshTokens_pk_columns_input!
  ): authRefreshTokens

  """
  update data of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshTokens(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  updateAuthRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input
    pk_columns: authRoles_pk_columns_input!
  ): authRoles

  """
  update data of the table: "auth.roles"
  """
  updateAuthRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input

    """filter the rows which have to be updated"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  update single row of the table: "auth.user_providers"
  """
  updateAuthUserProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input
    pk_columns: authUserProviders_pk_columns_input!
  ): authUserProviders

  """
  update data of the table: "auth.user_providers"
  """
  updateAuthUserProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input

    """filter the rows which have to be updated"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  update single row of the table: "auth.user_roles"
  """
  updateAuthUserRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input
    pk_columns: authUserRoles_pk_columns_input!
  ): authUserRoles

  """
  update data of the table: "auth.user_roles"
  """
  updateAuthUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input

    """filter the rows which have to be updated"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  update single row of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKey(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input
    pk_columns: authUserSecurityKeys_pk_columns_input!
  ): authUserSecurityKeys

  """
  update data of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKeys(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input

    """filter the rows which have to be updated"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  update single row of the table: "storage.buckets"
  """
  updateBucket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input
    pk_columns: buckets_pk_columns_input!
  ): buckets

  """
  update data of the table: "storage.buckets"
  """
  updateBuckets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input

    """filter the rows which have to be updated"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  update single row of the table: "storage.files"
  """
  updateFile(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "storage.files"
  """
  updateFiles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """Update user's profile"""
  updateMyProfile(args: JobUserInput!): uuid!

  """
  update single row of the table: "auth.users"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "auth.users"
  """
  updateUsers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update data of the table: "application_status"
  """
  update_application_status(
    """sets the columns of the filtered rows to the given values"""
    _set: application_status_set_input

    """filter the rows which have to be updated"""
    where: application_status_bool_exp!
  ): application_status_mutation_response

  """
  update single row of the table: "application_status"
  """
  update_application_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: application_status_set_input
    pk_columns: application_status_pk_columns_input!
  ): application_status

  """
  update multiples rows of table: "application_status"
  """
  update_application_status_many(
    """updates to execute, in order"""
    updates: [application_status_updates!]!
  ): [application_status_mutation_response]

  """
  update data of the table: "applications"
  """
  update_applications(
    """sets the columns of the filtered rows to the given values"""
    _set: applications_set_input

    """filter the rows which have to be updated"""
    where: applications_bool_exp!
  ): applications_mutation_response

  """
  update single row of the table: "applications"
  """
  update_applications_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: applications_set_input
    pk_columns: applications_pk_columns_input!
  ): applications

  """
  update multiples rows of table: "applications"
  """
  update_applications_many(
    """updates to execute, in order"""
    updates: [applications_updates!]!
  ): [applications_mutation_response]

  """
  update multiples rows of table: "auth.provider_requests"
  """
  update_authProviderRequests_many(
    """updates to execute, in order"""
    updates: [authProviderRequests_updates!]!
  ): [authProviderRequests_mutation_response]

  """
  update multiples rows of table: "auth.providers"
  """
  update_authProviders_many(
    """updates to execute, in order"""
    updates: [authProviders_updates!]!
  ): [authProviders_mutation_response]

  """
  update multiples rows of table: "auth.refresh_tokens"
  """
  update_authRefreshTokens_many(
    """updates to execute, in order"""
    updates: [authRefreshTokens_updates!]!
  ): [authRefreshTokens_mutation_response]

  """
  update multiples rows of table: "auth.roles"
  """
  update_authRoles_many(
    """updates to execute, in order"""
    updates: [authRoles_updates!]!
  ): [authRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_providers"
  """
  update_authUserProviders_many(
    """updates to execute, in order"""
    updates: [authUserProviders_updates!]!
  ): [authUserProviders_mutation_response]

  """
  update multiples rows of table: "auth.user_roles"
  """
  update_authUserRoles_many(
    """updates to execute, in order"""
    updates: [authUserRoles_updates!]!
  ): [authUserRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_security_keys"
  """
  update_authUserSecurityKeys_many(
    """updates to execute, in order"""
    updates: [authUserSecurityKeys_updates!]!
  ): [authUserSecurityKeys_mutation_response]

  """
  update multiples rows of table: "storage.buckets"
  """
  update_buckets_many(
    """updates to execute, in order"""
    updates: [buckets_updates!]!
  ): [buckets_mutation_response]

  """
  update data of the table: "companies"
  """
  update_companies(
    """sets the columns of the filtered rows to the given values"""
    _set: companies_set_input

    """filter the rows which have to be updated"""
    where: companies_bool_exp!
  ): companies_mutation_response

  """
  update single row of the table: "companies"
  """
  update_companies_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: companies_set_input
    pk_columns: companies_pk_columns_input!
  ): companies

  """
  update multiples rows of table: "companies"
  """
  update_companies_many(
    """updates to execute, in order"""
    updates: [companies_updates!]!
  ): [companies_mutation_response]

  """
  update data of the table: "company_sizes"
  """
  update_company_sizes(
    """sets the columns of the filtered rows to the given values"""
    _set: company_sizes_set_input

    """filter the rows which have to be updated"""
    where: company_sizes_bool_exp!
  ): company_sizes_mutation_response

  """
  update single row of the table: "company_sizes"
  """
  update_company_sizes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: company_sizes_set_input
    pk_columns: company_sizes_pk_columns_input!
  ): company_sizes

  """
  update multiples rows of table: "company_sizes"
  """
  update_company_sizes_many(
    """updates to execute, in order"""
    updates: [company_sizes_updates!]!
  ): [company_sizes_mutation_response]

  """
  update data of the table: "employments"
  """
  update_employments(
    """sets the columns of the filtered rows to the given values"""
    _set: employments_set_input

    """filter the rows which have to be updated"""
    where: employments_bool_exp!
  ): employments_mutation_response

  """
  update single row of the table: "employments"
  """
  update_employments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: employments_set_input
    pk_columns: employments_pk_columns_input!
  ): employments

  """
  update multiples rows of table: "employments"
  """
  update_employments_many(
    """updates to execute, in order"""
    updates: [employments_updates!]!
  ): [employments_mutation_response]

  """
  update multiples rows of table: "storage.files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "job_types"
  """
  update_job_types(
    """sets the columns of the filtered rows to the given values"""
    _set: job_types_set_input

    """filter the rows which have to be updated"""
    where: job_types_bool_exp!
  ): job_types_mutation_response

  """
  update single row of the table: "job_types"
  """
  update_job_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: job_types_set_input
    pk_columns: job_types_pk_columns_input!
  ): job_types

  """
  update multiples rows of table: "job_types"
  """
  update_job_types_many(
    """updates to execute, in order"""
    updates: [job_types_updates!]!
  ): [job_types_mutation_response]

  """
  update data of the table: "jobs"
  """
  update_jobs(
    """sets the columns of the filtered rows to the given values"""
    _set: jobs_set_input

    """filter the rows which have to be updated"""
    where: jobs_bool_exp!
  ): jobs_mutation_response

  """
  update single row of the table: "jobs"
  """
  update_jobs_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: jobs_set_input
    pk_columns: jobs_pk_columns_input!
  ): jobs

  """
  update multiples rows of table: "jobs"
  """
  update_jobs_many(
    """updates to execute, in order"""
    updates: [jobs_updates!]!
  ): [jobs_mutation_response]

  """
  update data of the table: "location_types"
  """
  update_location_types(
    """sets the columns of the filtered rows to the given values"""
    _set: location_types_set_input

    """filter the rows which have to be updated"""
    where: location_types_bool_exp!
  ): location_types_mutation_response

  """
  update single row of the table: "location_types"
  """
  update_location_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: location_types_set_input
    pk_columns: location_types_pk_columns_input!
  ): location_types

  """
  update multiples rows of table: "location_types"
  """
  update_location_types_many(
    """updates to execute, in order"""
    updates: [location_types_updates!]!
  ): [location_types_mutation_response]

  """
  update data of the table: "profile_types"
  """
  update_profile_types(
    """sets the columns of the filtered rows to the given values"""
    _set: profile_types_set_input

    """filter the rows which have to be updated"""
    where: profile_types_bool_exp!
  ): profile_types_mutation_response

  """
  update single row of the table: "profile_types"
  """
  update_profile_types_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: profile_types_set_input
    pk_columns: profile_types_pk_columns_input!
  ): profile_types

  """
  update multiples rows of table: "profile_types"
  """
  update_profile_types_many(
    """updates to execute, in order"""
    updates: [profile_types_updates!]!
  ): [profile_types_mutation_response]

  """
  update data of the table: "profiles"
  """
  update_profiles(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: profiles_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: profiles_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: profiles_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: profiles_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: profiles_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: profiles_set_input

    """filter the rows which have to be updated"""
    where: profiles_bool_exp!
  ): profiles_mutation_response

  """
  update single row of the table: "profiles"
  """
  update_profiles_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: profiles_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: profiles_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: profiles_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: profiles_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: profiles_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: profiles_set_input
    pk_columns: profiles_pk_columns_input!
  ): profiles

  """
  update multiples rows of table: "profiles"
  """
  update_profiles_many(
    """updates to execute, in order"""
    updates: [profiles_updates!]!
  ): [profiles_mutation_response]

  """
  update multiples rows of table: "auth.users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """Upload resume"""
  uploadResume(args: JobUserInput!): uuid!
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "profile_types"
"""
type profile_types {
  type_name: String!
}

"""
aggregated selection of "profile_types"
"""
type profile_types_aggregate {
  aggregate: profile_types_aggregate_fields
  nodes: [profile_types!]!
}

"""
aggregate fields of "profile_types"
"""
type profile_types_aggregate_fields {
  count(columns: [profile_types_select_column!], distinct: Boolean): Int!
  max: profile_types_max_fields
  min: profile_types_min_fields
}

"""
Boolean expression to filter rows from the table "profile_types". All fields are combined with a logical 'AND'.
"""
input profile_types_bool_exp {
  _and: [profile_types_bool_exp!]
  _not: profile_types_bool_exp
  _or: [profile_types_bool_exp!]
  type_name: String_comparison_exp
}

"""
unique or primary key constraints on table "profile_types"
"""
enum profile_types_constraint {
  """
  unique or primary key constraint on columns "type_name"
  """
  profile_types_pkey
}

"""
input type for inserting data into table "profile_types"
"""
input profile_types_insert_input {
  type_name: String
}

"""aggregate max on columns"""
type profile_types_max_fields {
  type_name: String
}

"""aggregate min on columns"""
type profile_types_min_fields {
  type_name: String
}

"""
response of any mutation on the table "profile_types"
"""
type profile_types_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [profile_types!]!
}

"""
on_conflict condition type for table "profile_types"
"""
input profile_types_on_conflict {
  constraint: profile_types_constraint!
  update_columns: [profile_types_update_column!]! = []
  where: profile_types_bool_exp
}

"""Ordering options when selecting data from "profile_types"."""
input profile_types_order_by {
  type_name: order_by
}

"""primary key columns input for table: profile_types"""
input profile_types_pk_columns_input {
  type_name: String!
}

"""
select columns of table "profile_types"
"""
enum profile_types_select_column {
  """column name"""
  type_name
}

"""
input type for updating data in table "profile_types"
"""
input profile_types_set_input {
  type_name: String
}

"""
Streaming cursor of the table "profile_types"
"""
input profile_types_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: profile_types_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input profile_types_stream_cursor_value_input {
  type_name: String
}

"""
update columns of table "profile_types"
"""
enum profile_types_update_column {
  """column name"""
  type_name
}

input profile_types_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: profile_types_set_input
  where: profile_types_bool_exp!
}

"""
columns and relationships of "profiles"
"""
type profiles {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String

  """An array relationship"""
  employments(
    """distinct select on columns"""
    distinct_on: [employments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employments_order_by!]

    """filter the rows returned"""
    where: employments_bool_exp
  ): [employments!]!

  """An aggregate relationship"""
  employments_aggregate(
    """distinct select on columns"""
    distinct_on: [employments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employments_order_by!]

    """filter the rows returned"""
    where: employments_bool_exp
  ): employments_aggregate!
  id: uuid!
  image: String
  name: String!
  profile_details(
    """JSON select path"""
    path: String
  ): jsonb
  telephone: String
  type: String
  updated_at: timestamptz

  """An object relationship"""
  user: users
  user_id: uuid!
}

"""
aggregated selection of "profiles"
"""
type profiles_aggregate {
  aggregate: profiles_aggregate_fields
  nodes: [profiles!]!
}

"""
aggregate fields of "profiles"
"""
type profiles_aggregate_fields {
  count(columns: [profiles_select_column!], distinct: Boolean): Int!
  max: profiles_max_fields
  min: profiles_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input profiles_append_input {
  profile_details: jsonb
}

"""
Boolean expression to filter rows from the table "profiles". All fields are combined with a logical 'AND'.
"""
input profiles_bool_exp {
  _and: [profiles_bool_exp!]
  _not: profiles_bool_exp
  _or: [profiles_bool_exp!]
  address: String_comparison_exp
  created_at: timestamptz_comparison_exp
  deleted_at: timestamptz_comparison_exp
  email: String_comparison_exp
  employments: employments_bool_exp
  employments_aggregate: employments_aggregate_bool_exp
  id: uuid_comparison_exp
  image: String_comparison_exp
  name: String_comparison_exp
  profile_details: jsonb_comparison_exp
  telephone: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "profiles"
"""
enum profiles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  profiles_pkey

  """
  unique or primary key constraint on columns "user_id"
  """
  profiles_userId_unique
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input profiles_delete_at_path_input {
  profile_details: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input profiles_delete_elem_input {
  profile_details: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input profiles_delete_key_input {
  profile_details: String
}

"""
input type for inserting data into table "profiles"
"""
input profiles_insert_input {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  employments: employments_arr_rel_insert_input
  id: uuid
  image: String
  name: String
  profile_details: jsonb
  telephone: String
  type: String
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type profiles_max_fields {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  image: String
  name: String
  telephone: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type profiles_min_fields {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  image: String
  name: String
  telephone: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "profiles"
"""
type profiles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [profiles!]!
}

"""
input type for inserting object relation for remote table "profiles"
"""
input profiles_obj_rel_insert_input {
  data: profiles_insert_input!

  """upsert condition"""
  on_conflict: profiles_on_conflict
}

"""
on_conflict condition type for table "profiles"
"""
input profiles_on_conflict {
  constraint: profiles_constraint!
  update_columns: [profiles_update_column!]! = []
  where: profiles_bool_exp
}

"""Ordering options when selecting data from "profiles"."""
input profiles_order_by {
  address: order_by
  created_at: order_by
  deleted_at: order_by
  email: order_by
  employments_aggregate: employments_aggregate_order_by
  id: order_by
  image: order_by
  name: order_by
  profile_details: order_by
  telephone: order_by
  type: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: profiles"""
input profiles_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input profiles_prepend_input {
  profile_details: jsonb
}

"""
select columns of table "profiles"
"""
enum profiles_select_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  profile_details

  """column name"""
  telephone

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "profiles"
"""
input profiles_set_input {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  image: String
  name: String
  profile_details: jsonb
  telephone: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "profiles"
"""
input profiles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: profiles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input profiles_stream_cursor_value_input {
  address: String
  created_at: timestamptz
  deleted_at: timestamptz
  email: String
  id: uuid
  image: String
  name: String
  profile_details: jsonb
  telephone: String
  type: String
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "profiles"
"""
enum profiles_update_column {
  """column name"""
  address

  """column name"""
  created_at

  """column name"""
  deleted_at

  """column name"""
  email

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  profile_details

  """column name"""
  telephone

  """column name"""
  type

  """column name"""
  updated_at

  """column name"""
  user_id
}

input profiles_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: profiles_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: profiles_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: profiles_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: profiles_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: profiles_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: profiles_set_input
  where: profiles_bool_exp!
}

type query_root {
  """List All Jobs"""
  allJobs(filter: JobsQueryInput): [Job]

  """
  fetch data from the table: "application_status"
  """
  application_status(
    """distinct select on columns"""
    distinct_on: [application_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [application_status_order_by!]

    """filter the rows returned"""
    where: application_status_bool_exp
  ): [application_status!]!

  """
  fetch aggregated fields from the table: "application_status"
  """
  application_status_aggregate(
    """distinct select on columns"""
    distinct_on: [application_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [application_status_order_by!]

    """filter the rows returned"""
    where: application_status_bool_exp
  ): application_status_aggregate!

  """
  fetch data from the table: "application_status" using primary key columns
  """
  application_status_by_pk(status: String!): application_status

  """An array relationship"""
  applications(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!

  """An aggregate relationship"""
  applications_aggregate(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): applications_aggregate!

  """fetch data from the table: "applications" using primary key columns"""
  applications_by_pk(job_id: uuid!, user_id: uuid!): applications

  """Apply for a job"""
  applyJob(
    """the unique id of an action"""
    id: uuid!
  ): applyJob

  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table: "companies"
  """
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """
  fetch aggregated fields from the table: "companies"
  """
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!

  """fetch data from the table: "companies" using primary key columns"""
  companies_by_pk(id: uuid!): companies

  """
  fetch data from the table: "company_sizes"
  """
  company_sizes(
    """distinct select on columns"""
    distinct_on: [company_sizes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_sizes_order_by!]

    """filter the rows returned"""
    where: company_sizes_bool_exp
  ): [company_sizes!]!

  """
  fetch aggregated fields from the table: "company_sizes"
  """
  company_sizes_aggregate(
    """distinct select on columns"""
    distinct_on: [company_sizes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_sizes_order_by!]

    """filter the rows returned"""
    where: company_sizes_bool_exp
  ): company_sizes_aggregate!

  """fetch data from the table: "company_sizes" using primary key columns"""
  company_sizes_by_pk(size: String!): company_sizes
  createMyProfile(
    """the unique id of an action"""
    id: uuid!
  ): createMyProfile

  """An array relationship"""
  employments(
    """distinct select on columns"""
    distinct_on: [employments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employments_order_by!]

    """filter the rows returned"""
    where: employments_bool_exp
  ): [employments!]!

  """An aggregate relationship"""
  employments_aggregate(
    """distinct select on columns"""
    distinct_on: [employments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employments_order_by!]

    """filter the rows returned"""
    where: employments_bool_exp
  ): employments_aggregate!

  """fetch data from the table: "employments" using primary key columns"""
  employments_by_pk(id: uuid!): employments

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """List all job applicants"""
  jobApplicants(filter: JobUserInput): [Profile]

  """
  fetch data from the table: "job_types"
  """
  job_types(
    """distinct select on columns"""
    distinct_on: [job_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_types_order_by!]

    """filter the rows returned"""
    where: job_types_bool_exp
  ): [job_types!]!

  """
  fetch aggregated fields from the table: "job_types"
  """
  job_types_aggregate(
    """distinct select on columns"""
    distinct_on: [job_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_types_order_by!]

    """filter the rows returned"""
    where: job_types_bool_exp
  ): job_types_aggregate!

  """fetch data from the table: "job_types" using primary key columns"""
  job_types_by_pk(type_name: String!): job_types

  """An array relationship"""
  jobs(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): [jobs!]!

  """An aggregate relationship"""
  jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): jobs_aggregate!

  """fetch data from the table: "jobs" using primary key columns"""
  jobs_by_pk(id: uuid!): jobs

  """
  fetch data from the table: "location_types"
  """
  location_types(
    """distinct select on columns"""
    distinct_on: [location_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [location_types_order_by!]

    """filter the rows returned"""
    where: location_types_bool_exp
  ): [location_types!]!

  """
  fetch aggregated fields from the table: "location_types"
  """
  location_types_aggregate(
    """distinct select on columns"""
    distinct_on: [location_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [location_types_order_by!]

    """filter the rows returned"""
    where: location_types_bool_exp
  ): location_types_aggregate!

  """fetch data from the table: "location_types" using primary key columns"""
  location_types_by_pk(location: String!): location_types

  """List user's job applications"""
  myApplications(filter: MyJobsQueryInput): [Job]
  myCompany(employer_id: uuid!): Company

  """List user's job posts"""
  myJobs(company_id: uuid!): [Job]

  """Get user's profile"""
  myProfile(user_id: Int!): Profile

  """
  fetch data from the table: "profile_types"
  """
  profile_types(
    """distinct select on columns"""
    distinct_on: [profile_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profile_types_order_by!]

    """filter the rows returned"""
    where: profile_types_bool_exp
  ): [profile_types!]!

  """
  fetch aggregated fields from the table: "profile_types"
  """
  profile_types_aggregate(
    """distinct select on columns"""
    distinct_on: [profile_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profile_types_order_by!]

    """filter the rows returned"""
    where: profile_types_bool_exp
  ): profile_types_aggregate!

  """fetch data from the table: "profile_types" using primary key columns"""
  profile_types_by_pk(type_name: String!): profile_types

  """
  fetch data from the table: "profiles"
  """
  profiles(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!

  """
  fetch aggregated fields from the table: "profiles"
  """
  profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): profiles_aggregate!

  """fetch data from the table: "profiles" using primary key columns"""
  profiles_by_pk(id: uuid!): profiles
  registerAsEmployer(
    """the unique id of an action"""
    id: uuid!
  ): registerAsEmployer

  """Register as job seeker"""
  registerAsSeeker(
    """the unique id of an action"""
    id: uuid!
  ): registerAsSeeker

  """Update user's profile"""
  updateMyProfile(
    """the unique id of an action"""
    id: uuid!
  ): updateMyProfile

  """Upload resume"""
  uploadResume(
    """the unique id of an action"""
    id: uuid!
  ): uploadResume

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
fields of action: "registerAsEmployer"
"""
type registerAsEmployer {
  """the time at which this action was created"""
  created_at: timestamptz!

  """errors related to the invocation"""
  errors: json

  """the unique id of an action"""
  id: uuid!

  """the output fields of this action"""
  output: Profile!
}

"""
fields of action: "registerAsSeeker"
"""
type registerAsSeeker {
  """the time at which this action was created"""
  created_at: timestamptz!

  """errors related to the invocation"""
  errors: json

  """the unique id of an action"""
  id: uuid!

  """the output fields of this action"""
  output: Profile!
}

type subscription_root {
  """
  fetch data from the table: "application_status"
  """
  application_status(
    """distinct select on columns"""
    distinct_on: [application_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [application_status_order_by!]

    """filter the rows returned"""
    where: application_status_bool_exp
  ): [application_status!]!

  """
  fetch aggregated fields from the table: "application_status"
  """
  application_status_aggregate(
    """distinct select on columns"""
    distinct_on: [application_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [application_status_order_by!]

    """filter the rows returned"""
    where: application_status_bool_exp
  ): application_status_aggregate!

  """
  fetch data from the table: "application_status" using primary key columns
  """
  application_status_by_pk(status: String!): application_status

  """
  fetch data from the table in a streaming manner: "application_status"
  """
  application_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [application_status_stream_cursor_input]!

    """filter the rows returned"""
    where: application_status_bool_exp
  ): [application_status!]!

  """An array relationship"""
  applications(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!

  """An aggregate relationship"""
  applications_aggregate(
    """distinct select on columns"""
    distinct_on: [applications_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [applications_order_by!]

    """filter the rows returned"""
    where: applications_bool_exp
  ): applications_aggregate!

  """fetch data from the table: "applications" using primary key columns"""
  applications_by_pk(job_id: uuid!, user_id: uuid!): applications

  """
  fetch data from the table in a streaming manner: "applications"
  """
  applications_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [applications_stream_cursor_input]!

    """filter the rows returned"""
    where: applications_bool_exp
  ): [applications!]!

  """Apply for a job"""
  applyJob(
    """the unique id of an action"""
    id: uuid!
  ): applyJob

  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.provider_requests"
  """
  authProviderRequests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviderRequests_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.providers"
  """
  authProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.refresh_tokens"
  """
  authRefreshTokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokens_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.roles"
  """
  authRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_providers"
  """
  authUserProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_roles"
  """
  authUserRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_security_keys"
  """
  authUserSecurityKeys_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserSecurityKeys_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.buckets"
  """
  buckets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [buckets_stream_cursor_input]!

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch data from the table: "companies"
  """
  companies(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """
  fetch aggregated fields from the table: "companies"
  """
  companies_aggregate(
    """distinct select on columns"""
    distinct_on: [companies_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [companies_order_by!]

    """filter the rows returned"""
    where: companies_bool_exp
  ): companies_aggregate!

  """fetch data from the table: "companies" using primary key columns"""
  companies_by_pk(id: uuid!): companies

  """
  fetch data from the table in a streaming manner: "companies"
  """
  companies_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [companies_stream_cursor_input]!

    """filter the rows returned"""
    where: companies_bool_exp
  ): [companies!]!

  """
  fetch data from the table: "company_sizes"
  """
  company_sizes(
    """distinct select on columns"""
    distinct_on: [company_sizes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_sizes_order_by!]

    """filter the rows returned"""
    where: company_sizes_bool_exp
  ): [company_sizes!]!

  """
  fetch aggregated fields from the table: "company_sizes"
  """
  company_sizes_aggregate(
    """distinct select on columns"""
    distinct_on: [company_sizes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [company_sizes_order_by!]

    """filter the rows returned"""
    where: company_sizes_bool_exp
  ): company_sizes_aggregate!

  """fetch data from the table: "company_sizes" using primary key columns"""
  company_sizes_by_pk(size: String!): company_sizes

  """
  fetch data from the table in a streaming manner: "company_sizes"
  """
  company_sizes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [company_sizes_stream_cursor_input]!

    """filter the rows returned"""
    where: company_sizes_bool_exp
  ): [company_sizes!]!
  createMyProfile(
    """the unique id of an action"""
    id: uuid!
  ): createMyProfile

  """An array relationship"""
  employments(
    """distinct select on columns"""
    distinct_on: [employments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employments_order_by!]

    """filter the rows returned"""
    where: employments_bool_exp
  ): [employments!]!

  """An aggregate relationship"""
  employments_aggregate(
    """distinct select on columns"""
    distinct_on: [employments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [employments_order_by!]

    """filter the rows returned"""
    where: employments_bool_exp
  ): employments_aggregate!

  """fetch data from the table: "employments" using primary key columns"""
  employments_by_pk(id: uuid!): employments

  """
  fetch data from the table in a streaming manner: "employments"
  """
  employments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [employments_stream_cursor_input]!

    """filter the rows returned"""
    where: employments_bool_exp
  ): [employments!]!

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "job_types"
  """
  job_types(
    """distinct select on columns"""
    distinct_on: [job_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_types_order_by!]

    """filter the rows returned"""
    where: job_types_bool_exp
  ): [job_types!]!

  """
  fetch aggregated fields from the table: "job_types"
  """
  job_types_aggregate(
    """distinct select on columns"""
    distinct_on: [job_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [job_types_order_by!]

    """filter the rows returned"""
    where: job_types_bool_exp
  ): job_types_aggregate!

  """fetch data from the table: "job_types" using primary key columns"""
  job_types_by_pk(type_name: String!): job_types

  """
  fetch data from the table in a streaming manner: "job_types"
  """
  job_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [job_types_stream_cursor_input]!

    """filter the rows returned"""
    where: job_types_bool_exp
  ): [job_types!]!

  """An array relationship"""
  jobs(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): [jobs!]!

  """An aggregate relationship"""
  jobs_aggregate(
    """distinct select on columns"""
    distinct_on: [jobs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [jobs_order_by!]

    """filter the rows returned"""
    where: jobs_bool_exp
  ): jobs_aggregate!

  """fetch data from the table: "jobs" using primary key columns"""
  jobs_by_pk(id: uuid!): jobs

  """
  fetch data from the table in a streaming manner: "jobs"
  """
  jobs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [jobs_stream_cursor_input]!

    """filter the rows returned"""
    where: jobs_bool_exp
  ): [jobs!]!

  """
  fetch data from the table: "location_types"
  """
  location_types(
    """distinct select on columns"""
    distinct_on: [location_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [location_types_order_by!]

    """filter the rows returned"""
    where: location_types_bool_exp
  ): [location_types!]!

  """
  fetch aggregated fields from the table: "location_types"
  """
  location_types_aggregate(
    """distinct select on columns"""
    distinct_on: [location_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [location_types_order_by!]

    """filter the rows returned"""
    where: location_types_bool_exp
  ): location_types_aggregate!

  """fetch data from the table: "location_types" using primary key columns"""
  location_types_by_pk(location: String!): location_types

  """
  fetch data from the table in a streaming manner: "location_types"
  """
  location_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [location_types_stream_cursor_input]!

    """filter the rows returned"""
    where: location_types_bool_exp
  ): [location_types!]!

  """
  fetch data from the table: "profile_types"
  """
  profile_types(
    """distinct select on columns"""
    distinct_on: [profile_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profile_types_order_by!]

    """filter the rows returned"""
    where: profile_types_bool_exp
  ): [profile_types!]!

  """
  fetch aggregated fields from the table: "profile_types"
  """
  profile_types_aggregate(
    """distinct select on columns"""
    distinct_on: [profile_types_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profile_types_order_by!]

    """filter the rows returned"""
    where: profile_types_bool_exp
  ): profile_types_aggregate!

  """fetch data from the table: "profile_types" using primary key columns"""
  profile_types_by_pk(type_name: String!): profile_types

  """
  fetch data from the table in a streaming manner: "profile_types"
  """
  profile_types_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [profile_types_stream_cursor_input]!

    """filter the rows returned"""
    where: profile_types_bool_exp
  ): [profile_types!]!

  """
  fetch data from the table: "profiles"
  """
  profiles(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!

  """
  fetch aggregated fields from the table: "profiles"
  """
  profiles_aggregate(
    """distinct select on columns"""
    distinct_on: [profiles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [profiles_order_by!]

    """filter the rows returned"""
    where: profiles_bool_exp
  ): profiles_aggregate!

  """fetch data from the table: "profiles" using primary key columns"""
  profiles_by_pk(id: uuid!): profiles

  """
  fetch data from the table in a streaming manner: "profiles"
  """
  profiles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [profiles_stream_cursor_input]!

    """filter the rows returned"""
    where: profiles_bool_exp
  ): [profiles!]!
  registerAsEmployer(
    """the unique id of an action"""
    id: uuid!
  ): registerAsEmployer

  """Register as job seeker"""
  registerAsSeeker(
    """the unique id of an action"""
    id: uuid!
  ): registerAsSeeker

  """Update user's profile"""
  updateMyProfile(
    """the unique id of an action"""
    id: uuid!
  ): updateMyProfile

  """Upload resume"""
  uploadResume(
    """the unique id of an action"""
    id: uuid!
  ): uploadResume

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
fields of action: "updateMyProfile"
"""
type updateMyProfile {
  """the time at which this action was created"""
  created_at: timestamptz!

  """errors related to the invocation"""
  errors: json

  """the unique id of an action"""
  id: uuid!

  """the output fields of this action"""
  output: Profile
}

"""
fields of action: "uploadResume"
"""
type uploadResume {
  """the time at which this action was created"""
  created_at: timestamptz!

  """errors related to the invocation"""
  errors: json

  """the unique id of an action"""
  id: uuid!

  """the output fields of this action"""
  output: Profile
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
  activeMfaType: String
  avatarUrl: String!
  createdAt: timestamptz!
  currentChallenge: String
  defaultRole: String!

  """An object relationship"""
  defaultRoleByRole: authRoles!
  disabled: Boolean!
  displayName: String!
  email: citext
  emailVerified: Boolean!
  id: uuid!
  isAnonymous: Boolean!
  lastSeen: timestamptz
  locale: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz!
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean!

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  securityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """An aggregate relationship"""
  securityKeys_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!
  ticket: String
  ticketExpiresAt: timestamptz!
  totpSecret: String
  updatedAt: timestamptz!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "auth.users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input users_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  activeMfaType: String_comparison_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  currentChallenge: String_comparison_exp
  defaultRole: String_comparison_exp
  defaultRoleByRole: authRoles_bool_exp
  disabled: Boolean_comparison_exp
  displayName: String_comparison_exp
  email: citext_comparison_exp
  emailVerified: Boolean_comparison_exp
  id: uuid_comparison_exp
  isAnonymous: Boolean_comparison_exp
  lastSeen: timestamptz_comparison_exp
  locale: String_comparison_exp
  metadata: jsonb_comparison_exp
  newEmail: citext_comparison_exp
  otpHash: String_comparison_exp
  otpHashExpiresAt: timestamptz_comparison_exp
  otpMethodLastUsed: String_comparison_exp
  passwordHash: String_comparison_exp
  phoneNumber: String_comparison_exp
  phoneNumberVerified: Boolean_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  refreshTokens_aggregate: authRefreshTokens_aggregate_bool_exp
  roles: authUserRoles_bool_exp
  roles_aggregate: authUserRoles_aggregate_bool_exp
  securityKeys: authUserSecurityKeys_bool_exp
  securityKeys_aggregate: authUserSecurityKeys_aggregate_bool_exp
  ticket: String_comparison_exp
  ticketExpiresAt: timestamptz_comparison_exp
  totpSecret: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  users_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input users_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input users_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input users_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.users"
"""
input users_insert_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  defaultRoleByRole: authRoles_obj_rel_insert_input
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  roles: authUserRoles_arr_rel_insert_input
  securityKeys: authUserSecurityKeys_arr_rel_insert_input
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth.users"
"""
input users_max_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth.users"
"""
input users_min_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "auth.users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "auth.users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "auth.users"."""
input users_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  defaultRoleByRole: authRoles_order_by
  disabled: order_by
  displayName: order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  isAnonymous: order_by
  lastSeen: order_by
  locale: order_by
  metadata: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  phoneNumberVerified: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  roles_aggregate: authUserRoles_aggregate_order_by
  securityKeys_aggregate: authUserSecurityKeys_aggregate_order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.users"""
input users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input users_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
update columns of table "auth.users"
"""
enum users_update_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

input users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: users_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}